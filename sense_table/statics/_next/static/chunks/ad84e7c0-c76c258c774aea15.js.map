{"version":3,"file":"static/chunks/ad84e7c0-c76c258c774aea15.js","mappings":"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","sources":["webpack://_N_E/./node_modules/.pnpm/jsonata@2.0.6/node_modules/jsonata/jsonata.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.jsonata = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n *  Copyright IBM Corp. 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nconst utils = require('./utils');\n\n/**\n * DateTime formatting and parsing functions\n * Implements the xpath-functions format-date-time specification\n * @type {{formatInteger, formatDateTime, parseInteger, parseDateTime}}\n */\nconst dateTime = (function () {\n    'use strict';\n\n    const stringToArray = utils.stringToArray;\n\n    const few = ['Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten',\n        'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen'];\n    const ordinals = ['Zeroth', 'First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth', 'Ninth', 'Tenth',\n        'Eleventh', 'Twelfth', 'Thirteenth', 'Fourteenth', 'Fifteenth', 'Sixteenth', 'Seventeenth', 'Eighteenth', 'Nineteenth'];\n    const decades = ['Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety', 'Hundred'];\n    const magnitudes = ['Thousand', 'Million', 'Billion', 'Trillion'];\n\n    /**\n     * converts a number into english words\n     * @param {string} value - the value to format\n     * @param {boolean} ordinal - ordinal or cardinal form\n     * @returns {string} - representation in words\n     */\n    function numberToWords(value, ordinal) {\n        var lookup = function (num, prev, ord) {\n            var words = '';\n            if (num <= 19) {\n                words = (prev ? ' and ' : '') + (ord ? ordinals[num] : few[num]);\n            } else if (num < 100) {\n                const tens = Math.floor(num / 10);\n                const remainder = num % 10;\n                words = (prev ? ' and ' : '') + decades[tens - 2];\n                if (remainder > 0) {\n                    words += '-' + lookup(remainder, false, ord);\n                } else if (ord) {\n                    words = words.substring(0, words.length - 1) + 'ieth';\n                }\n            } else if (num < 1000) {\n                const hundreds = Math.floor(num / 100);\n                const remainder = num % 100;\n                words = (prev ? ', ' : '') + few[hundreds] + ' Hundred';\n                if (remainder > 0) {\n                    words += lookup(remainder, true, ord);\n                } else if (ord) {\n                    words += 'th';\n                }\n            } else {\n                var mag = Math.floor(Math.log10(num) / 3);\n                if (mag > magnitudes.length) {\n                    mag = magnitudes.length; // the largest word\n                }\n                const factor = Math.pow(10, mag * 3);\n                const mant = Math.floor(num / factor);\n                const remainder = num - mant * factor;\n                words = (prev ? ', ' : '') + lookup(mant, false, false) + ' ' + magnitudes[mag - 1];\n                if (remainder > 0) {\n                    words += lookup(remainder, true, ord);\n                } else if (ord) {\n                    words += 'th';\n                }\n            }\n            return words;\n        };\n\n        var words = lookup(value, false, ordinal);\n        return words;\n    }\n\n    const wordValues = {};\n    few.forEach(function (word, index) {\n        wordValues[word.toLowerCase()] = index;\n    });\n    ordinals.forEach(function (word, index) {\n        wordValues[word.toLowerCase()] = index;\n    });\n    decades.forEach(function (word, index) {\n        const lword = word.toLowerCase();\n        wordValues[lword] = (index + 2) * 10;\n        wordValues[lword.substring(0, word.length - 1) + 'ieth'] = wordValues[lword];\n    });\n    wordValues.hundredth = 100;\n    magnitudes.forEach(function (word, index) {\n        const lword = word.toLowerCase();\n        const val = Math.pow(10, (index + 1) * 3);\n        wordValues[lword] = val;\n        wordValues[lword + 'th'] = val;\n    });\n\n    /**\n     * Converts a number in english words to numeric value\n     * @param {string} text - the number in words\n     * @returns {number} - the numeric value\n     */\n    function wordsToNumber(text) {\n        const parts = text.split(/,\\s|\\sand\\s|[\\s\\\\-]/);\n        const values = parts.map(part => wordValues[part]);\n        let segs = [0];\n        values.forEach(value => {\n            if (value < 100) {\n                let top = segs.pop();\n                if (top >= 1000) {\n                    segs.push(top);\n                    top = 0;\n                }\n                segs.push(top + value);\n            } else {\n                segs.push(segs.pop() * value);\n            }\n        });\n        const result = segs.reduce((a, b) => a + b, 0);\n        return result;\n    }\n\n    const romanNumerals = [\n        [1000, 'm'],\n        [900, 'cm'],\n        [500, 'd'],\n        [400, 'cd'],\n        [100, 'c'],\n        [90, 'xc'],\n        [50, 'l'],\n        [40, 'xl'],\n        [10, 'x'],\n        [9, 'ix'],\n        [5, 'v'],\n        [4, 'iv'],\n        [1, 'i']\n    ];\n\n    const romanValues = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1};\n\n    /**\n     * converts a number to roman numerals\n     * @param {number} value - the number\n     * @returns {string} - the number in roman numerals\n     */\n    function decimalToRoman(value) {\n        for (var index = 0; index < romanNumerals.length; index++) {\n            const numeral = romanNumerals[index];\n            if (value >= numeral[0]) {\n                return numeral[1] + decimalToRoman(value - numeral[0]);\n            }\n        }\n        return '';\n    }\n\n    /**\n     * converts roman numerals to a number\n     * @param {string} roman - roman number\n     * @returns {number} - the numeric value\n     */\n    function romanToDecimal(roman) {\n        var decimal = 0;\n        var max = 1;\n        for (var i = roman.length - 1; i >= 0; i--) {\n            const digit = roman[i];\n            const value = romanValues[digit];\n            if (value < max) {\n                decimal -= value;\n            } else {\n                max = value;\n                decimal += value;\n            }\n        }\n        return decimal;\n    }\n\n    /**\n     * converts a number to spreadsheet style letters\n     * @param {number} value - the number\n     * @param {string} aChar - the character representing the start of the sequence, e.g. 'A'\n     * @returns {string} - the letters\n     */\n    function decimalToLetters(value, aChar) {\n        var letters = [];\n        var aCode = aChar.charCodeAt(0);\n        while (value > 0) {\n            letters.unshift(String.fromCharCode((value - 1) % 26 + aCode));\n            value = Math.floor((value - 1) / 26);\n        }\n        return letters.join('');\n    }\n\n    /**\n     * converts spreadsheet style letters to a number\n     * @param {string} letters - the letters\n     * @param {string} aChar - the character representing the start of the sequence, e.g. 'A'\n     * @returns {number} - the numeric value\n     */\n    function lettersToDecimal(letters, aChar) {\n        var aCode = aChar.charCodeAt(0);\n        var decimal = 0;\n        for (var i = 0; i < letters.length; i++) {\n            decimal += (letters.charCodeAt(letters.length - i - 1) - aCode + 1) * Math.pow(26, i);\n        }\n        return decimal;\n    }\n\n    /**\n     * Formats an integer as specified by the XPath fn:format-integer function\n     * See https://www.w3.org/TR/xpath-functions-31/#func-format-integer\n     * @param {number} value - the number to be formatted\n     * @param {string} picture - the picture string that specifies the format\n     * @returns {string} - the formatted number\n     */\n    function formatInteger(value, picture) {\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        value = Math.floor(value);\n\n        const format = analyseIntegerPicture(picture);\n        return _formatInteger(value, format);\n    }\n\n    const formats = {\n        DECIMAL: 'decimal',\n        LETTERS: 'letters',\n        ROMAN: 'roman',\n        WORDS: 'words',\n        SEQUENCE: 'sequence'\n    };\n\n    const tcase = {\n        UPPER: 'upper',\n        LOWER: 'lower',\n        TITLE: 'title'\n    };\n\n    /**\n     * formats an integer using a preprocessed representation of the picture string\n     * @param {number} value - the number to be formatted\n     * @param {object} format - the preprocessed representation of the pucture string\n     * @returns {string} - the formatted number\n     * @private\n     */\n    function _formatInteger(value, format) {\n        let formattedInteger;\n        const negative = value < 0;\n        value = Math.abs(value);\n        switch (format.primary) {\n            case formats.LETTERS:\n                formattedInteger = decimalToLetters(value, format.case === tcase.UPPER ? 'A' : 'a');\n                break;\n            case formats.ROMAN:\n                formattedInteger = decimalToRoman(value);\n                if (format.case === tcase.UPPER) {\n                    formattedInteger = formattedInteger.toUpperCase();\n                }\n                break;\n            case formats.WORDS:\n                formattedInteger = numberToWords(value, format.ordinal);\n                if (format.case === tcase.UPPER) {\n                    formattedInteger = formattedInteger.toUpperCase();\n                } else if (format.case === tcase.LOWER) {\n                    formattedInteger = formattedInteger.toLowerCase();\n                }\n                break;\n            case formats.DECIMAL:\n                formattedInteger = '' + value;\n                // TODO use functionPad\n                var padLength = format.mandatoryDigits - formattedInteger.length;\n                if (padLength > 0) {\n                    var padding = (new Array(padLength + 1)).join('0');\n                    formattedInteger = padding + formattedInteger;\n                }\n                if (format.zeroCode !== 0x30) {\n                    formattedInteger = stringToArray(formattedInteger).map(code => {\n                        return String.fromCodePoint(code.codePointAt(0) + format.zeroCode - 0x30);\n                    }).join('');\n                }\n                // insert the grouping-separator-signs, if any\n                if (format.regular) {\n                    const n = Math.floor((formattedInteger.length - 1) / format.groupingSeparators.position);\n                    for (let ii = n; ii > 0; ii--) {\n                        const pos = formattedInteger.length - ii * format.groupingSeparators.position;\n                        formattedInteger = formattedInteger.substr(0, pos) + format.groupingSeparators.character + formattedInteger.substr(pos);\n                    }\n                } else {\n                    format.groupingSeparators.reverse().forEach(separator => {\n                        const pos = formattedInteger.length - separator.position;\n                        formattedInteger = formattedInteger.substr(0, pos) + separator.character + formattedInteger.substr(pos);\n                    });\n                }\n\n                if (format.ordinal) {\n                    var suffix123 = {'1': 'st', '2': 'nd', '3': 'rd'};\n                    var lastDigit = formattedInteger[formattedInteger.length - 1];\n                    var suffix = suffix123[lastDigit];\n                    if (!suffix || (formattedInteger.length > 1 && formattedInteger[formattedInteger.length - 2] === '1')) {\n                        suffix = 'th';\n                    }\n                    formattedInteger = formattedInteger + suffix;\n                }\n                break;\n            case formats.SEQUENCE:\n                throw {\n                    code: 'D3130',\n                    value: format.token\n                };\n        }\n        if (negative) {\n            formattedInteger = '-' + formattedInteger;\n        }\n\n        return formattedInteger;\n    }\n\n    //TODO what about decimal groups in the unicode supplementary planes (surrogate pairs) ???\n    const decimalGroups = [0x30, 0x0660, 0x06F0, 0x07C0, 0x0966, 0x09E6, 0x0A66, 0x0AE6, 0x0B66, 0x0BE6, 0x0C66, 0x0CE6, 0x0D66, 0x0DE6, 0x0E50, 0x0ED0, 0x0F20, 0x1040, 0x1090, 0x17E0, 0x1810, 0x1946, 0x19D0, 0x1A80, 0x1A90, 0x1B50, 0x1BB0, 0x1C40, 0x1C50, 0xA620, 0xA8D0, 0xA900, 0xA9D0, 0xA9F0, 0xAA50, 0xABF0, 0xFF10];\n\n    /**\n     * preprocesses the picture string\n     * @param {string} picture - picture string\n     * @returns {{type: string, primary: string, case: string, ordinal: boolean}} - analysed picture\n     */\n    function analyseIntegerPicture(picture) {\n        const format = {\n            type: 'integer',\n            primary: formats.DECIMAL,\n            case: tcase.LOWER,\n            ordinal: false\n        };\n\n        let primaryFormat, formatModifier;\n        const semicolon = picture.lastIndexOf(';');\n        if (semicolon === -1) {\n            primaryFormat = picture;\n        } else {\n            primaryFormat = picture.substring(0, semicolon);\n            formatModifier = picture.substring(semicolon + 1);\n            if (formatModifier[0] === 'o') {\n                format.ordinal = true;\n            }\n        }\n\n        /* eslnt-disable-next no-fallthrough */\n        switch (primaryFormat) {\n            case 'A':\n                format.case = tcase.UPPER;\n            /* eslnt-disable-next-line no-fallthrough */\n            case 'a':\n                format.primary = formats.LETTERS;\n                break;\n            case 'I':\n                format.case = tcase.UPPER;\n            /* eslnt-disable-next-line no-fallthrough */\n            case 'i':\n                format.primary = formats.ROMAN;\n                break;\n            case 'W':\n                format.case = tcase.UPPER;\n                format.primary = formats.WORDS;\n                break;\n            case 'Ww':\n                format.case = tcase.TITLE;\n                format.primary = formats.WORDS;\n                break;\n            case 'w':\n                format.primary = formats.WORDS;\n                break;\n            default: {\n                // this is a decimal-digit-pattern if it contains a decimal digit (from any unicode decimal digit group)\n                let zeroCode = null;\n                let mandatoryDigits = 0;\n                let optionalDigits = 0;\n                let groupingSeparators = [];\n                let separatorPosition = 0;\n                const formatCodepoints = stringToArray(primaryFormat).map(c => c.codePointAt(0)).reverse(); // reverse the array to determine positions of grouping-separator-signs\n                formatCodepoints.forEach((codePoint) => {\n                    // step though each char in the picture to determine the digit group\n                    let digit = false;\n                    for (let ii = 0; ii < decimalGroups.length; ii++) {\n                        const group = decimalGroups[ii];\n                        if (codePoint >= group && codePoint <= group + 9) {\n                            // codepoint is part of this decimal group\n                            digit = true;\n                            mandatoryDigits++;\n                            separatorPosition++;\n                            if (zeroCode === null) {\n                                zeroCode = group;\n                            } else if (group !== zeroCode) {\n                                // error! different decimal groups in the same pattern\n                                throw {\n                                    code: 'D3131'\n                                };\n                            }\n                            break;\n                        }\n                    }\n                    if (!digit) {\n                        if (codePoint === 0x23) { // # - optional-digit-sign\n                            separatorPosition++;\n                            optionalDigits++;\n                        } else {\n                            // neither a decimal-digit-sign ot optional-digit-sign, assume it is a grouping-separator-sign\n                            groupingSeparators.push({\n                                position: separatorPosition,\n                                character: String.fromCodePoint(codePoint)\n                            });\n                        }\n                    }\n                });\n                if (mandatoryDigits > 0) {\n                    format.primary = formats.DECIMAL;\n                    // TODO validate decimal-digit-pattern\n\n                    // the decimal digit family (codepoint offset)\n                    format.zeroCode = zeroCode;\n                    // the number of mandatory digits\n                    format.mandatoryDigits = mandatoryDigits;\n                    // the number of optional digits\n                    format.optionalDigits = optionalDigits;\n                    // grouping separator template\n                    // are the grouping-separator-signs 'regular'?\n                    const regularRepeat = function (separators) {\n                        // are the grouping positions regular? i.e. same interval between each of them\n                        // is there at least one separator?\n                        if (separators.length === 0) {\n                            return 0;\n                        }\n                        // are all the characters the same?\n                        const sepChar = separators[0].character;\n                        for (let ii = 1; ii < separators.length; ii++) {\n                            if (separators[ii].character !== sepChar) {\n                                return 0;\n                            }\n                        }\n                        // are they equally spaced?\n                        const indexes = separators.map(separator => separator.position);\n                        const gcd = function (a, b) {\n                            return b === 0 ? a : gcd(b, a % b);\n                        };\n                        // find the greatest common divisor of all the positions\n                        const factor = indexes.reduce(gcd);\n                        // is every position separated by this divisor? If so, it's regular\n                        for (let index = 1; index <= indexes.length; index++) {\n                            if (indexes.indexOf(index * factor) === -1) {\n                                return 0;\n                            }\n                        }\n                        return factor;\n                    };\n\n                    const regular = regularRepeat(groupingSeparators);\n                    if (regular > 0) {\n                        format.regular = true;\n                        format.groupingSeparators = {\n                            position: regular,\n                            character: groupingSeparators[0].character\n                        };\n                    } else {\n                        format.regular = false;\n                        format.groupingSeparators = groupingSeparators;\n                    }\n\n                } else {\n                    // this is a 'numbering sequence' which the spec says is implementation-defined\n                    // this implementation doesn't support any numbering sequences at the moment.\n                    format.primary = formats.SEQUENCE;\n                    format.token = primaryFormat;\n                }\n            }\n        }\n\n        return format;\n    }\n\n    const defaultPresentationModifiers = {\n        Y: '1', M: '1', D: '1', d: '1', F: 'n', W: '1', w: '1', X: '1', x: '1', H: '1', h: '1',\n        P: 'n', m: '01', s: '01', f: '1', Z: '01:01', z: '01:01', C: 'n', E: 'n'\n    };\n\n    // 9.8.4.1 the format specifier is an array of string literals and variable markers\n    /**\n     * analyse the date-time picture string\n     * @param {string} picture - picture string\n     * @returns {{type: string, parts: Array}} - the analysed string\n     */\n    function analyseDateTimePicture(picture) {\n        var spec = [];\n        const format = {\n            type: 'datetime',\n            parts: spec\n        };\n        const addLiteral = function (start, end) {\n            if (end > start) {\n                let literal = picture.substring(start, end);\n                // replace any doubled ]] with single ]\n                // what if there are instances of single ']' ? - the spec doesn't say\n                literal = literal.split(']]').join(']');\n                spec.push({type: 'literal', value: literal});\n            }\n        };\n\n        var start = 0, pos = 0;\n        while (pos < picture.length) {\n            if (picture.charAt(pos) === '[') {\n                // check it's not a doubled [[\n                if (picture.charAt(pos + 1) === '[') {\n                    // literal [\n                    addLiteral(start, pos);\n                    spec.push({type: 'literal', value: '['});\n                    pos += 2;\n                    start = pos;\n                    continue;\n                }\n                // start of variable marker\n                // push the string literal (if there is one) onto the array\n                addLiteral(start, pos);\n                start = pos;\n                // search forward to closing ]\n                pos = picture.indexOf(']', start);\n                // TODO handle error case if pos === -1\n                if(pos === -1) {\n                    // error - no closing bracket\n                    throw {\n                        code: 'D3135'\n                    };\n                }\n                let marker = picture.substring(start + 1, pos);\n                // whitespace within a variable marker is ignored (i.e. remove it)\n                marker = marker.split(/\\s+/).join('');\n                var def = {\n                    type: 'marker',\n                    component: marker.charAt(0)  // 1. The component specifier is always present and is always a single letter.\n                };\n                var comma = marker.lastIndexOf(','); // 2. The width modifier may be recognized by the presence of a comma\n                var presMod; // the presentation modifiers\n                if (comma !== -1) {\n                    // 9.8.4.2 The Width Modifier\n                    const widthMod = marker.substring(comma + 1);\n                    const dash = widthMod.indexOf('-');\n                    let min, max;\n                    const parseWidth = function (wm) {\n                        if (typeof wm === 'undefined' || wm === '*') {\n                            return undefined;\n                        } else {\n                            // TODO validate wm is an unsigned int\n                            return parseInt(wm);\n                        }\n                    };\n                    if (dash === -1) {\n                        min = widthMod;\n                    } else {\n                        min = widthMod.substring(0, dash);\n                        max = widthMod.substring(dash + 1);\n                    }\n                    const widthDef = {\n                        min: parseWidth(min),\n                        max: parseWidth(max)\n                    };\n                    def.width = widthDef;\n                    presMod = marker.substring(1, comma);\n                } else {\n                    presMod = marker.substring(1);\n                }\n                if (presMod.length === 1) {\n                    def.presentation1 = presMod; // first presentation modifier\n                    //TODO validate the first presentation modifier - it's either N, n, Nn or it passes analyseIntegerPicture\n                } else if (presMod.length > 1) {\n                    var lastChar = presMod.charAt(presMod.length - 1);\n                    if ('atco'.indexOf(lastChar) !== -1) {\n                        def.presentation2 = lastChar;\n                        if (lastChar === 'o') {\n                            def.ordinal = true;\n                        }\n                        // 'c' means 'cardinal' and is the default (i.e. not 'ordinal')\n                        // 'a' & 't' are ignored (not sure of their relevance to English numbering)\n                        def.presentation1 = presMod.substring(0, presMod.length - 1);\n                    } else {\n                        def.presentation1 = presMod;\n                        //TODO validate the first presentation modifier - it's either N, n, Nn or it passes analyseIntegerPicture,\n                        // doesn't use ] as grouping separator, and if grouping separator is , then must have width modifier\n                    }\n                } else {\n                    // no presentation modifier specified - apply the default;\n                    def.presentation1 = defaultPresentationModifiers[def.component];\n                }\n                if (typeof def.presentation1 === 'undefined') {\n                    // unknown component specifier\n                    throw {\n                        code: 'D3132',\n                        value: def.component\n                    };\n                }\n                if (def.presentation1[0] === 'n') {\n                    def.names = tcase.LOWER;\n                } else if (def.presentation1[0] === 'N') {\n                    if (def.presentation1[1] === 'n') {\n                        def.names = tcase.TITLE;\n                    } else {\n                        def.names = tcase.UPPER;\n                    }\n                } else if ('YMDdFWwXxHhmsf'.indexOf(def.component) !== -1) {\n                    var integerPattern = def.presentation1;\n                    if (def.presentation2) {\n                        integerPattern += ';' + def.presentation2;\n                    }\n                    def.integerFormat = analyseIntegerPicture(integerPattern);\n                    if (def.width && def.width.min !== undefined) {\n                        if (def.integerFormat.mandatoryDigits < def.width.min) {\n                            def.integerFormat.mandatoryDigits = def.width.min;\n                        }\n                    }\n                    if ('YMD'.indexOf(def.component) !== -1) {\n                        // 9.8.4.4\n                        def.n = -1;\n                        if (def.width && def.width.max !== undefined) {\n                            def.n = def.width.max;\n                            def.integerFormat.mandatoryDigits = def.n;\n                        } else {\n                            var w = def.integerFormat.mandatoryDigits + def.integerFormat.optionalDigits;\n                            if (w >= 2) {\n                                def.n = w;\n                            }\n                        }\n                    }\n                }\n                if (def.component === 'Z' || def.component === 'z') {\n                    def.integerFormat = analyseIntegerPicture(def.presentation1);\n                }\n                spec.push(def);\n                start = pos + 1;\n            }\n            pos++;\n        }\n        addLiteral(start, pos);\n        return format;\n    }\n\n    const days = ['', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];\n    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n    const millisInADay = 1000 * 60 * 60 * 24;\n\n    const startOfFirstWeek = function (ym) {\n        // ISO 8601 defines the first week of the year to be the week that contains the first Thursday\n        // XPath F&O extends this same definition for the first week of a month\n        // the week starts on a Monday - calculate the millis for the start of the first week\n        // millis for given 1st Jan of that year (at 00:00 UTC)\n        const jan1 = Date.UTC(ym.year, ym.month);\n        var dayOfJan1 = (new Date(jan1)).getUTCDay();\n        if (dayOfJan1 === 0) {\n            dayOfJan1 = 7;\n        }\n        // if Jan 1 is Fri, Sat or Sun, then add the number of days (in millis) to jan1 to get the start of week 1\n        return dayOfJan1 > 4 ? jan1 + (8 - dayOfJan1) * millisInADay : jan1 - (dayOfJan1 - 1) * millisInADay;\n    };\n\n    const yearMonth = function (year, month) {\n        return {\n            year: year,\n            month: month,\n            nextMonth: function () {\n                return (month === 11) ? yearMonth(year + 1, 0) : yearMonth(year, month + 1);\n            },\n            previousMonth: function () {\n                return (month === 0) ? yearMonth(year - 1, 11) : yearMonth(year, month - 1);\n            },\n            nextYear: function () {\n                return yearMonth(year + 1, month);\n            },\n            previousYear: function () {\n                return yearMonth(year - 1, month);\n            }\n        };\n    };\n\n    const deltaWeeks = function (start, end) {\n        return (end - start) / (millisInADay * 7) + 1;\n    };\n\n    const getDateTimeFragment = (date, component) => {\n        let componentValue;\n        switch (component) {\n            case 'Y': // year\n                componentValue = date.getUTCFullYear();\n                break;\n            case 'M': // month in year\n                componentValue = date.getUTCMonth() + 1;\n                break;\n            case 'D': // day in month\n                componentValue = date.getUTCDate();\n                break;\n            case 'd': { // day in year\n                // millis for given date (at 00:00 UTC)\n                const today = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());\n                // millis for given 1st Jan of that year (at 00:00 UTC)\n                const firstJan = Date.UTC(date.getUTCFullYear(), 0);\n                componentValue = (today - firstJan) / millisInADay + 1;\n                break;\n            }\n            case 'F': // day of week\n                componentValue = date.getUTCDay();\n                if (componentValue === 0) {\n                    // ISO 8601 defines days 1-7: Mon-Sun\n                    componentValue = 7;\n                }\n                break;\n            case 'W': { // week in year\n                const thisYear = yearMonth(date.getUTCFullYear(), 0);\n                const startOfWeek1 = startOfFirstWeek(thisYear);\n                const today = Date.UTC(thisYear.year, date.getUTCMonth(), date.getUTCDate());\n                let week = deltaWeeks(startOfWeek1, today);\n                if (week > 52) {\n                    // might be first week of the following year\n                    const startOfFollowingYear = startOfFirstWeek(thisYear.nextYear());\n                    if (today >= startOfFollowingYear) {\n                        week = 1;\n                    }\n                } else if (week < 1) {\n                    // must be end of the previous year\n                    const startOfPreviousYear = startOfFirstWeek(thisYear.previousYear());\n                    week = deltaWeeks(startOfPreviousYear, today);\n                }\n                componentValue = Math.floor(week);\n                break;\n            }\n            case 'w': { // week in month\n                const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());\n                const startOfWeek1 = startOfFirstWeek(thisMonth);\n                const today = Date.UTC(thisMonth.year, thisMonth.month, date.getUTCDate());\n                let week = deltaWeeks(startOfWeek1, today);\n                if (week > 4) {\n                    // might be first week of the following month\n                    const startOfFollowingMonth = startOfFirstWeek(thisMonth.nextMonth());\n                    if (today >= startOfFollowingMonth) {\n                        week = 1;\n                    }\n                } else if (week < 1) {\n                    // must be end of the previous month\n                    const startOfPreviousMonth = startOfFirstWeek(thisMonth.previousMonth());\n                    week = deltaWeeks(startOfPreviousMonth, today);\n                }\n                componentValue = Math.floor(week);\n                break;\n            }\n            case 'X': { // ISO week-numbering year\n                // Extension: The F&O spec says nothing about how to access the year associated with the week-of-the-year\n                // e.g. Sat 1 Jan 2005 is in the 53rd week of 2004.\n                // The 'W' component specifier gives 53, but 'Y' will give 2005.\n                // I propose to add 'X' as the component specifier to give the ISO week-numbering year (2004 in this example)\n                const thisYear = yearMonth(date.getUTCFullYear(), 0);\n                const startOfISOYear = startOfFirstWeek(thisYear);\n                const endOfISOYear = startOfFirstWeek(thisYear.nextYear());\n                const now = date.getTime();\n                if (now < startOfISOYear) {\n                    componentValue = thisYear.year - 1;\n                } else if (now >= endOfISOYear) {\n                    componentValue = thisYear.year + 1;\n                } else {\n                    componentValue = thisYear.year;\n                }\n                break;\n            }\n            case 'x': { // ISO week-numbering month\n                // Extension: The F&O spec says nothing about how to access the month associated with the week-of-the-month\n                // e.g. Sat 1 Jan 2005 is in the 5th week of December 2004.\n                // The 'w' component specifier gives 5, but 'W' will give January and 'Y' will give 2005.\n                // I propose to add 'x' as the component specifier to give the 'week-numbering' month (December in this example)\n                const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());\n                const startOfISOMonth = startOfFirstWeek(thisMonth);\n                const nextMonth = thisMonth.nextMonth();\n                const endOfISOMonth = startOfFirstWeek(nextMonth);\n                const now = date.getTime();\n                if (now < startOfISOMonth) {\n                    componentValue = thisMonth.previousMonth().month + 1;\n                } else if (now >= endOfISOMonth) {\n                    componentValue = nextMonth.month + 1;\n                } else {\n                    componentValue = thisMonth.month + 1;\n                }\n                break;\n            }\n            case 'H': // hour in day (24 hours)\n                componentValue = date.getUTCHours();\n                break;\n            case 'h': // hour in half-day (12 hours)\n                componentValue = date.getUTCHours();\n                componentValue = componentValue % 12;\n                if (componentValue === 0) {\n                    componentValue = 12;\n                }\n                break;\n            case 'P': // am/pm marker\n                componentValue = date.getUTCHours() >= 12 ? 'pm' : 'am';\n                break;\n            case 'm': // minute in hour\n                componentValue = date.getUTCMinutes();\n                break;\n            case 's': // second in minute\n                componentValue = date.getUTCSeconds();\n                break;\n            case 'f': // fractional seconds\n                componentValue = date.getUTCMilliseconds();\n                break;\n            case 'Z': // timezone\n            case 'z':\n                // since the date object is constructed from epoch millis, the TZ component is always be UTC.\n                break;\n            case 'C': // calendar name\n                componentValue = 'ISO';\n                break;\n            case 'E': // era\n                componentValue = 'ISO';\n                break;\n        }\n        return componentValue;\n    };\n\n    let iso8601Spec = null;\n\n    /**\n     * formats the date/time as specified by the XPath fn:format-dateTime function\n     * @param {number} millis - the timestamp to be formatted, in millis since the epoch\n     * @param {string} picture - the picture string that specifies the format\n     * @param {string} timezone - the timezone to use\n     * @returns {string} - the formatted timestamp\n     */\n    function formatDateTime(millis, picture, timezone) {\n        var offsetHours = 0;\n        var offsetMinutes = 0;\n\n        if (typeof timezone !== 'undefined') {\n            // parse the hour and minute offsets\n            // assume for now the format supplied is +hhmm\n            const offset = parseInt(timezone);\n            offsetHours = Math.floor(offset / 100);\n            offsetMinutes = offset % 100;\n        }\n\n        var formatComponent = function (date, markerSpec) {\n            var componentValue = getDateTimeFragment(date, markerSpec.component);\n\n            // 9.8.4.3 Formatting Integer-Valued Date/Time Components\n            if ('YMDdFWwXxHhms'.indexOf(markerSpec.component) !== -1) {\n                if (markerSpec.component === 'Y') {\n                    // 9.8.4.4 Formatting the Year Component\n                    if (markerSpec.n !== -1) {\n                        componentValue = componentValue % Math.pow(10, markerSpec.n);\n                    }\n                }\n                if (markerSpec.names) {\n                    if (markerSpec.component === 'M' || markerSpec.component === 'x') {\n                        componentValue = months[componentValue - 1];\n                    } else if (markerSpec.component === 'F') {\n                        componentValue = days[componentValue];\n                    } else {\n                        throw {\n                            code: 'D3133',\n                            value: markerSpec.component\n                        };\n                    }\n                    if (markerSpec.names === tcase.UPPER) {\n                        componentValue = componentValue.toUpperCase();\n                    } else if (markerSpec.names === tcase.LOWER) {\n                        componentValue = componentValue.toLowerCase();\n                    }\n                    if (markerSpec.width && componentValue.length > markerSpec.width.max) {\n                        componentValue = componentValue.substring(0, markerSpec.width.max);\n                    }\n                } else {\n                    componentValue = _formatInteger(componentValue, markerSpec.integerFormat);\n                }\n            } else if (markerSpec.component === 'f') {\n                // TODO 9.8.4.5 Formatting Fractional Seconds\n                componentValue = _formatInteger(componentValue, markerSpec.integerFormat);\n            } else if (markerSpec.component === 'Z' || markerSpec.component === 'z') {\n                // 9.8.4.6 Formatting timezones\n                const offset = offsetHours * 100 + offsetMinutes;\n                if (markerSpec.integerFormat.regular) {\n                    componentValue = _formatInteger(offset, markerSpec.integerFormat);\n                } else {\n                    const numDigits = markerSpec.integerFormat.mandatoryDigits;\n                    if (numDigits === 1 || numDigits === 2) {\n                        componentValue = _formatInteger(offsetHours, markerSpec.integerFormat);\n                        if (offsetMinutes !== 0) {\n                            componentValue += ':' + formatInteger(offsetMinutes, '00');\n                        }\n                    } else if (numDigits === 3 || numDigits === 4) {\n                        componentValue = _formatInteger(offset, markerSpec.integerFormat);\n                    } else {\n                        throw {\n                            code: 'D3134',\n                            value: numDigits\n                        };\n                    }\n                }\n                if (offset >= 0) {\n                    componentValue = '+' + componentValue;\n                }\n                if (markerSpec.component === 'z') {\n                    componentValue = 'GMT' + componentValue;\n                }\n                if (offset === 0 && markerSpec.presentation2 === 't') {\n                    componentValue = 'Z';\n                }\n            } else if (markerSpec.component === 'P') {\n                // 9.8.4.7 Formatting Other Components\n                // Formatting P for am/pm\n                // getDateTimeFragment() always returns am/pm lower case so check for UPPER here\n                if (markerSpec.names === tcase.UPPER) {\n                    componentValue = componentValue.toUpperCase();\n                }\n            }\n            return componentValue;\n        };\n\n        let formatSpec;\n        if(typeof picture === 'undefined') {\n            // default to ISO 8601 format\n            if (iso8601Spec === null) {\n                iso8601Spec = analyseDateTimePicture('[Y0001]-[M01]-[D01]T[H01]:[m01]:[s01].[f001][Z01:01t]');\n            }\n            formatSpec = iso8601Spec;\n        } else {\n            formatSpec = analyseDateTimePicture(picture);\n        }\n\n        const offsetMillis = (60 * offsetHours + offsetMinutes) * 60 * 1000;\n        const dateTime = new Date(millis + offsetMillis);\n\n        let result = '';\n        formatSpec.parts.forEach(function (part) {\n            if (part.type === 'literal') {\n                result += part.value;\n            } else {\n                result += formatComponent(dateTime, part);\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Generate a regex to parse integers or timestamps\n     * @param {object} formatSpec - object representing the format\n     * @returns {object} - regex\n     */\n    function generateRegex(formatSpec) {\n        var matcher = {};\n        if (formatSpec.type === 'datetime') {\n            matcher.type = 'datetime';\n            matcher.parts = formatSpec.parts.map(function (part) {\n                var res = {};\n                if (part.type === 'literal') {\n                    res.regex = part.value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n                } else if (part.component === 'Z' || part.component === 'z') {\n                    // timezone\n                    let separator;\n                    if (!Array.isArray(part.integerFormat.groupingSeparators)) {\n                        separator = part.integerFormat.groupingSeparators;\n                    }\n                    res.regex = '';\n                    if (part.component === 'z') {\n                        res.regex = 'GMT';\n                    }\n                    res.regex += '[-+][0-9]+';\n                    if (separator) {\n                        res.regex += separator.character + '[0-9]+';\n                    }\n                    res.parse = function(value) {\n                        if (part.component === 'z') {\n                            value = value.substring(3); // remove the leading GMT\n                        }\n                        let offsetHours = 0, offsetMinutes = 0;\n                        if (separator) {\n                            offsetHours = Number.parseInt(value.substring(0, value.indexOf(separator.character)));\n                            offsetMinutes = Number.parseInt(value.substring(value.indexOf(separator.character) + 1));\n                        } else {\n                            // depends on number of digits\n                            const numdigits = value.length - 1;\n                            if (numdigits <= 2) {\n                                // just hour offset\n                                offsetHours = Number.parseInt(value);\n                            } else {\n                                offsetHours = Number.parseInt(value.substring(0, 3));\n                                offsetMinutes = Number.parseInt(value.substring(3));\n                            }\n                        }\n                        return offsetHours * 60 + offsetMinutes;\n                    };\n                } else if (part.integerFormat) {\n                    part.integerFormat.n = part.n;\n                    res = generateRegex(part.integerFormat);\n                } else {\n                    // must be a month or day name\n                    res.regex = '[a-zA-Z]+';\n                    var lookup = {};\n                    if (part.component === 'M' || part.component === 'x') {\n                        // months\n                        months.forEach(function (name, index) {\n                            if (part.width && part.width.max) {\n                                lookup[name.substring(0, part.width.max)] = index + 1;\n                            } else {\n                                lookup[name] = index + 1;\n                            }\n                        });\n                    } else if (part.component === 'F') {\n                        // days\n                        days.forEach(function (name, index) {\n                            if (index > 0) {\n                                if (part.width && part.width.max) {\n                                    lookup[name.substring(0, part.width.max)] = index;\n                                } else {\n                                    lookup[name] = index;\n                                }\n                            }\n                        });\n                    } else if (part.component === 'P') {\n                        lookup = {'am': 0, 'AM': 0, 'pm': 1, 'PM': 1};\n                    } else {\n                        // unsupported 'name' option for this component\n                        throw {\n                            code: 'D3133',\n                            value: part.component\n                        };\n                    }\n                    res.parse = function (value) {\n                        return lookup[value];\n                    };\n                }\n                res.component = part.component;\n                return res;\n            });\n        } else { // type === 'integer'\n            matcher.type = 'integer';\n            const isUpper = formatSpec.case === tcase.UPPER;\n            let occurrences;\n            if(formatSpec.n && formatSpec.n > 0){\n                if(formatSpec.optionalDigits === 0){\n                    occurrences = `{${formatSpec.n}}`;\n                } else {\n                    occurrences = `{${formatSpec.n - formatSpec.optionalDigits},${formatSpec.n}}`;\n                }\n            } else {\n                occurrences = '+';\n            }\n\n            switch (formatSpec.primary) {\n                case formats.LETTERS:\n                    matcher.regex = isUpper ? '[A-Z]+' : '[a-z]+';\n                    matcher.parse = function (value) {\n                        return lettersToDecimal(value, isUpper ? 'A' : 'a');\n                    };\n                    break;\n                case formats.ROMAN:\n                    matcher.regex = isUpper ? '[MDCLXVI]+' : '[mdclxvi]+';\n                    matcher.parse = function (value) {\n                        return romanToDecimal(isUpper ? value : value.toUpperCase());\n                    };\n                    break;\n                case formats.WORDS:\n                    matcher.regex = '(?:' + Object.keys(wordValues).concat('and', '[\\\\-, ]').join('|') + ')+';\n                    matcher.parse = function (value) {\n                        return wordsToNumber(value.toLowerCase());\n                    };\n                    break;\n                case formats.DECIMAL:\n                    matcher.regex = `[0-9]${occurrences}`;\n                    if (formatSpec.ordinal) {\n                        // ordinals\n                        matcher.regex += '(?:th|st|nd|rd)';\n                    }\n                    matcher.parse = function (value) {\n                        let digits = value;\n                        if (formatSpec.ordinal) {\n                            // strip off the suffix\n                            digits = value.substring(0, value.length - 2);\n                        }\n                        // strip out the separators\n                        if (formatSpec.regular) {\n                            digits = digits.split(',').join('');\n                        } else {\n                            formatSpec.groupingSeparators.forEach(sep => {\n                                digits = digits.split(sep.character).join('');\n                            });\n                        }\n                        if (formatSpec.zeroCode !== 0x30) {\n                            // apply offset\n                            digits = digits.split('').map(char => String.fromCodePoint(char.codePointAt(0) - formatSpec.zeroCode + 0x30)).join('');\n                        }\n                        return parseInt(digits);\n                    };\n                    break;\n                case formats.SEQUENCE:\n                    throw {\n                        code: 'D3130',\n                        value: formatSpec.token\n                    };\n            }\n\n        }\n        return matcher;\n    }\n\n    /**\n     * parse a string containing an integer as specified by the picture string\n     * @param {string} value - the string to parse\n     * @param {string} picture - the picture string\n     * @returns {number} - the parsed number\n     */\n    function parseInteger(value, picture) {\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        const formatSpec = analyseIntegerPicture(picture);\n        const matchSpec = generateRegex(formatSpec);\n        //const fullRegex = '^' + matchSpec.regex + '$';\n        //const matcher = new RegExp(fullRegex);\n        // TODO validate input based on the matcher regex\n        const result = matchSpec.parse(value);\n        return result;\n    }\n\n    /**\n     * parse a string containing a timestamp as specified by the picture string\n     * @param {string} timestamp - the string to parse\n     * @param {string} picture - the picture string\n     * @returns {number} - the parsed timestamp in millis since the epoch\n     */\n    function parseDateTime(timestamp, picture) {\n        const formatSpec = analyseDateTimePicture(picture);\n        const matchSpec = generateRegex(formatSpec);\n        const fullRegex = '^' + matchSpec.parts.map(part => '(' + part.regex + ')').join('') + '$';\n\n        const matcher = new RegExp(fullRegex, 'i'); // TODO can cache this against the picture\n        var info = matcher.exec(timestamp);\n        if (info !== null) {\n            // validate what we've just parsed - do we have enough information to create a timestamp?\n            // rules:\n            // The date is specified by one of:\n            //    {Y, M, D}    (dateA)\n            // or {Y, d}       (dateB)\n            // or {Y, x, w, F} (dateC)\n            // or {X, W, F}    (dateD)\n            // The time is specified by one of:\n            //    {H, m, s, f}    (timeA)\n            // or {P, h, m, s, f} (timeB)\n            // All sets can have an optional Z\n            // To create a timestamp (epoch millis) we need both date and time, but we can default missing\n            // information according to the following rules:\n            // - line up one combination of the above from date, and one from time, most significant value (MSV) to least significant (LSV\n            // - for the values that have been captured, if there are any gaps between MSV and LSV, then throw an error\n            //     (e.g.) if hour and seconds, but not minutes is given - throw\n            //     (e.g.) if month, hour and minutes, but not day-of-month is given - throw\n            // - anything right of the LSV should be defaulted to zero\n            //     (e.g.) if hour and minutes given, default seconds and fractional seconds to zero\n            //     (e.g.) if date only given, default the time to 0:00:00.000 (midnight)\n            // - anything left of the MSV should be defaulted to the value of that component returned by $now()\n            //     (e.g.) if time only given, default the date to today\n            //     (e.g.) if month and date given, default to this year (and midnight, by previous rule)\n            //   -- default values for X, x, W, w, F will be derived from the values returned by $now()\n\n            // implement the above rules\n            // determine which of the above date/time combinations we have by using bit masks\n\n            //        Y X M x W w d D F P H h m s f Z\n            // dateA  1 0 1 0 0 0 0 1 ?                     0 - must not appear\n            // dateB  1 0 0 0 0 0 1 0 ?                     1 - can appear - relevant\n            // dateC  0 1 0 1 0 1 0 0 1                     ? - can appear - ignored\n            // dateD  0 1 0 0 1 0 0 0 1\n            // timeA                    0 1 0 1 1 1\n            // timeB                    1 0 1 1 1 1\n\n            // create bitmasks based on the above\n            //    date mask             YXMxWwdD\n            const dmA = 161;  // binary 10100001\n            const dmB = 130;  // binary 10000010\n            const dmC = 84;   // binary 01010100\n            const dmD = 72;   // binary 01001000\n            //    time mask             PHhmsf\n            const tmA = 23;   // binary 010111\n            const tmB = 47;   // binary 101111\n\n            const components = {};\n            for (let i = 1; i < info.length; i++) {\n                const mpart = matchSpec.parts[i - 1];\n                if (mpart.parse) {\n                    components[mpart.component] = mpart.parse(info[i]);\n                }\n            }\n\n            if(Object.getOwnPropertyNames(components).length === 0) {\n                // nothing specified\n                return undefined;\n            }\n\n            let mask = 0;\n\n            const shift = bit => {\n                mask <<= 1;\n                mask += bit ? 1 : 0;\n            };\n\n            const isType = type => {\n                // shouldn't match any 0's, must match at least one 1\n                return !(~type & mask) && !!(type & mask);\n            };\n\n            'YXMxWwdD'.split('').forEach(part => shift(components[part]));\n\n            const dateA = isType(dmA);\n            const dateB = !dateA && isType(dmB);\n            const dateC = isType(dmC);\n            const dateD = !dateC && isType(dmD);\n\n            mask = 0;\n            'PHhmsf'.split('').forEach(part => shift(components[part]));\n\n            const timeA = isType(tmA);\n            const timeB = !timeA && isType(tmB);\n\n            // should only be zero or one date type and zero or one time type\n\n            const dateComps = dateB ? 'YD' : dateC ? 'XxwF' : dateD? 'XWF' : 'YMD';\n            const timeComps = timeB ? 'Phmsf' : 'Hmsf';\n\n            const comps = dateComps + timeComps;\n\n            // step through the candidate parts from most significant to least significant\n            // default the most significant unspecified parts to current timestamp component\n            // default the least significant unspecified parts to zero\n            // if any gaps in between the specified parts, throw an error\n\n            const now = this.environment.timestamp; // must get the fixed timestamp from jsonata\n\n            let startSpecified = false;\n            let endSpecified = false;\n            comps.split('').forEach(part => {\n                if(typeof components[part] === 'undefined') {\n                    if(startSpecified) {\n                        // past the specified block - default to zero\n                        components[part] = ('MDd'.indexOf(part) !== -1) ? 1 : 0;\n                        endSpecified = true;\n                    } else {\n                        // haven't hit the specified block yet, default to current timestamp\n                        components[part] = getDateTimeFragment(now, part);\n                    }\n                } else {\n                    startSpecified = true;\n                    if(endSpecified) {\n                        throw {\n                            code: 'D3136'\n                        };\n                    }\n                }\n            });\n\n            // validate and fill in components\n            if (components.M > 0) {\n                components.M -= 1;  // Date.UTC requires a zero-indexed month\n            } else {\n                components.M = 0; // default to January\n            }\n            if (dateB) {\n                // millis for given 1st Jan of that year (at 00:00 UTC)\n                const firstJan = Date.UTC(components.Y, 0);\n                const offsetMillis = (components.d - 1) * 1000 * 60 * 60 * 24;\n                const derivedDate = new Date(firstJan + offsetMillis);\n                components.M = derivedDate.getUTCMonth();\n                components.D = derivedDate.getUTCDate();\n            }\n            if (dateC) {\n                // TODO implement this\n                // parsing this format not currently supported\n                throw {\n                    code: 'D3136'\n                };\n            }\n            if (dateD) {\n                // TODO implement this\n                // parsing this format (ISO week date) not currently supported\n                throw {\n                    code: 'D3136'\n                };\n            }\n            if (timeB) {\n                // 12hr to 24hr\n                components.H = components.h === 12 ? 0 : components.h;\n                if (components.P === 1) {\n                    components.H += 12;\n                }\n            }\n\n            var millis = Date.UTC(components.Y, components.M, components.D, components.H, components.m, components.s, components.f);\n            if(components.Z || components.z) {\n                // adjust for timezone\n                millis -= (components.Z || components.z) * 60 * 1000;\n            }\n            return millis;\n        }\n    }\n\n    // Regular expression to match an ISO 8601 formatted timestamp\n    var iso8601regex = new RegExp('^\\\\d{4}(-[01]\\\\d)*(-[0-3]\\\\d)*(T[0-2]\\\\d:[0-5]\\\\d:[0-5]\\\\d)*(\\\\.\\\\d+)?([+-][0-2]\\\\d:?[0-5]\\\\d|Z)?$');\n\n    /**\n     * Converts an ISO 8601 timestamp to milliseconds since the epoch\n     *\n     * @param {string} timestamp - the timestamp to be converted\n     * @param {string} [picture] - the picture string defining the format of the timestamp (defaults to ISO 8601)\n     * @returns {Number} - milliseconds since the epoch\n     */\n    function toMillis(timestamp, picture) {\n        // undefined inputs always return undefined\n        if(typeof timestamp === 'undefined') {\n            return undefined;\n        }\n\n        if(typeof picture === 'undefined') {\n            if (!iso8601regex.test(timestamp)) {\n                throw {\n                    stack: (new Error()).stack,\n                    code: \"D3110\",\n                    value: timestamp\n                };\n            }\n\n            return Date.parse(timestamp);\n        } else {\n            return parseDateTime.call(this, timestamp, picture);\n        }\n    }\n\n    /**\n     * Converts milliseconds since the epoch to an ISO 8601 timestamp\n     * @param {Number} millis - milliseconds since the epoch to be converted\n     * @param {string} [picture] - the picture string defining the format of the timestamp (defaults to ISO 8601)\n     * @param {string} [timezone] - the timezone to format the timestamp in (defaults to UTC)\n     * @returns {String} - the formatted timestamp\n     */\n    function fromMillis(millis, picture, timezone) {\n        // undefined inputs always return undefined\n        if(typeof millis === 'undefined') {\n            return undefined;\n        }\n\n        return formatDateTime.call(this, millis, picture, timezone);\n    }\n\n    return {\n        formatInteger, parseInteger, fromMillis, toMillis\n    };\n})();\n\nmodule.exports = dateTime;\n\n},{\"./utils\":6}],2:[function(require,module,exports){\n(function (global){(function (){\n/**\n *  Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nvar utils = require('./utils');\n\nconst functions = (() => {\n    'use strict';\n\n    var isNumeric = utils.isNumeric;\n    var isArrayOfStrings = utils.isArrayOfStrings;\n    var isArrayOfNumbers = utils.isArrayOfNumbers;\n    var createSequence = utils.createSequence;\n    var isSequence = utils.isSequence;\n    var isFunction = utils.isFunction;\n    var isLambda = utils.isLambda;\n    var isPromise = utils.isPromise;\n    var getFunctionArity = utils.getFunctionArity;\n    var deepEquals = utils.isDeepEqual;\n    var stringToArray = utils.stringToArray;\n\n    /**\n     * Sum function\n     * @param {Object} args - Arguments\n     * @returns {number} Total value of arguments\n     */\n    function sum(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined') {\n            return undefined;\n        }\n\n        var total = 0;\n        args.forEach(function (num) {\n            total += num;\n        });\n        return total;\n    }\n\n    /**\n     * Count function\n     * @param {Object} args - Arguments\n     * @returns {number} Number of elements in the array\n     */\n    function count(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined') {\n            return 0;\n        }\n\n        return args.length;\n    }\n\n    /**\n     * Max function\n     * @param {Object} args - Arguments\n     * @returns {number} Max element in the array\n     */\n    function max(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined' || args.length === 0) {\n            return undefined;\n        }\n\n        return Math.max.apply(Math, args);\n    }\n\n    /**\n     * Min function\n     * @param {Object} args - Arguments\n     * @returns {number} Min element in the array\n     */\n    function min(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined' || args.length === 0) {\n            return undefined;\n        }\n\n        return Math.min.apply(Math, args);\n    }\n\n    /**\n     * Average function\n     * @param {Object} args - Arguments\n     * @returns {number} Average element in the array\n     */\n    function average(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined' || args.length === 0) {\n            return undefined;\n        }\n\n        var total = 0;\n        args.forEach(function (num) {\n            total += num;\n        });\n        return total / args.length;\n    }\n\n    /**\n     * Stringify arguments\n     * @param {Object} arg - Arguments\n     * @param {boolean} [prettify] - Pretty print the result\n     * @returns {String} String from arguments\n     */\n    function string(arg, prettify = false) {\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        var str;\n\n        if (typeof arg === 'string') {\n            // already a string\n            str = arg;\n        } else if (isFunction(arg)) {\n            // functions (built-in and lambda convert to empty string\n            str = '';\n        } else if (typeof arg === 'number' && !isFinite(arg)) {\n            throw {\n                code: \"D3001\",\n                value: arg,\n                stack: (new Error()).stack\n            };\n        } else {\n            var space = prettify ? 2 : 0;\n            if(Array.isArray(arg) && arg.outerWrapper) {\n                arg = arg[0];\n            }\n            str = JSON.stringify(arg, function (key, val) {\n                return (typeof val !== 'undefined' && val !== null && val.toPrecision && isNumeric(val)) ? Number(val.toPrecision(15)) :\n                    (val && isFunction(val)) ? '' : val;\n            }, space);\n        }\n        return str;\n    }\n\n    /**\n     * Create substring based on character number and length\n     * @param {String} str - String to evaluate\n     * @param {Integer} start - Character number to start substring\n     * @param {Integer} [length] - Number of characters in substring\n     * @returns {string|*} Substring\n     */\n    function substring(str, start, length) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var strArray = stringToArray(str);\n        var strLength = strArray.length;\n\n        if (strLength + start < 0) {\n            start = 0;\n        }\n\n        if (typeof length !== 'undefined') {\n            if (length <= 0) {\n                return '';\n            }\n            var end = start >= 0 ? start + length : strLength + start + length;\n            return strArray.slice(start, end).join('');\n        }\n\n        return strArray.slice(start).join('');\n    }\n\n    /**\n     * Create substring up until a character\n     * @param {String} str - String to evaluate\n     * @param {String} chars - Character to define substring boundary\n     * @returns {*} Substring\n     */\n    function substringBefore(str, chars) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var pos = str.indexOf(chars);\n        if (pos > -1) {\n            return str.substr(0, pos);\n        } else {\n            return str;\n        }\n    }\n\n    /**\n     * Create substring after a character\n     * @param {String} str - String to evaluate\n     * @param {String} chars - Character to define substring boundary\n     * @returns {*} Substring\n     */\n    function substringAfter(str, chars) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var pos = str.indexOf(chars);\n        if (pos > -1) {\n            return str.substr(pos + chars.length);\n        } else {\n            return str;\n        }\n    }\n\n    /**\n     * Lowercase a string\n     * @param {String} str - String to evaluate\n     * @returns {string} Lowercase string\n     */\n    function lowercase(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        return str.toLowerCase();\n    }\n\n    /**\n     * Uppercase a string\n     * @param {String} str - String to evaluate\n     * @returns {string} Uppercase string\n     */\n    function uppercase(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        return str.toUpperCase();\n    }\n\n    /**\n     * length of a string\n     * @param {String} str - string\n     * @returns {Number} The number of characters in the string\n     */\n    function length(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        return stringToArray(str).length;\n    }\n\n    /**\n     * Normalize and trim whitespace within a string\n     * @param {string} str - string to be trimmed\n     * @returns {string} - trimmed string\n     */\n    function trim(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // normalize whitespace\n        var result = str.replace(/[ \\t\\n\\r]+/gm, ' ');\n        if (result.charAt(0) === ' ') {\n            // strip leading space\n            result = result.substring(1);\n        }\n        if (result.charAt(result.length - 1) === ' ') {\n            // strip trailing space\n            result = result.substring(0, result.length - 1);\n        }\n        return result;\n    }\n\n    /**\n     * Pad a string to a minimum width by adding characters to the start or end\n     * @param {string} str - string to be padded\n     * @param {number} width - the minimum width; +ve pads to the right, -ve pads to the left\n     * @param {string} [char] - the pad character(s); defaults to ' '\n     * @returns {string} - padded string\n     */\n    function pad(str, width, char) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        if (typeof char === 'undefined' || char.length === 0) {\n            char = ' ';\n        }\n\n        var result;\n        var padLength = Math.abs(width) - length(str);\n        if (padLength > 0) {\n            var padding = (new Array(padLength + 1)).join(char);\n            if (char.length > 1) {\n                padding = substring(padding, 0, padLength);\n            }\n            if (width > 0) {\n                result = str + padding;\n            } else {\n                result = padding + str;\n            }\n        } else {\n            result = str;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate the matcher function against the str arg\n     *\n     * @param {*} matcher - matching function (native or lambda)\n     * @param {string} str - the string to match against\n     * @returns {object} - structure that represents the match(es)\n     */\n    async function evaluateMatcher(matcher, str) {\n        var result = matcher.apply(this, [str]); // eslint-disable-line no-useless-call\n        if(isPromise(result)) {\n            result = await result;\n        }\n        if(result && !(typeof result.start === 'number' || result.end === 'number' || Array.isArray(result.groups) || isFunction(result.next))) {\n            // the matcher function didn't return the correct structure\n            throw {\n                code: \"T1010\",\n                stack: (new Error()).stack,\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Tests if the str contains the token\n     * @param {String} str - string to test\n     * @param {String} token - substring or regex to find\n     * @returns {Boolean} - true if str contains token\n     */\n    async function contains(str, token) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var result;\n\n        if (typeof token === 'string') {\n            result = (str.indexOf(token) !== -1);\n        } else {\n            var matches = await evaluateMatcher(token, str);\n            result = (typeof matches !== 'undefined');\n        }\n\n        return result;\n    }\n\n    /**\n     * Match a string with a regex returning an array of object containing details of each match\n     * @param {String} str - string\n     * @param {String} regex - the regex applied to the string\n     * @param {Integer} [limit] - max number of matches to return\n     * @returns {Array} The array of match objects\n     */\n    async function match(str, regex, limit) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // limit, if specified, must be a non-negative number\n        if (limit < 0) {\n            throw {\n                stack: (new Error()).stack,\n                value: limit,\n                code: 'D3040',\n                index: 3\n            };\n        }\n\n        var result = createSequence();\n\n        if (typeof limit === 'undefined' || limit > 0) {\n            var count = 0;\n            var matches = await evaluateMatcher(regex, str);\n            if (typeof matches !== 'undefined') {\n                while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {\n                    result.push({\n                        match: matches.match,\n                        index: matches.start,\n                        groups: matches.groups\n                    });\n                    matches = await evaluateMatcher(matches.next);\n                    count++;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Match a string with a regex returning an array of object containing details of each match\n     * @param {String} str - string\n     * @param {String} pattern - the substring/regex applied to the string\n     * @param {String} replacement - text to replace the matched substrings\n     * @param {Integer} [limit] - max number of matches to return\n     * @returns {Array} The array of match objects\n     */\n    async function replace(str, pattern, replacement, limit) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var self = this;\n\n        // pattern cannot be an empty string\n        if (pattern === '') {\n            throw {\n                code: \"D3010\",\n                stack: (new Error()).stack,\n                value: pattern,\n                index: 2\n            };\n        }\n\n        // limit, if specified, must be a non-negative number\n        if (limit < 0) {\n            throw {\n                code: \"D3011\",\n                stack: (new Error()).stack,\n                value: limit,\n                index: 4\n            };\n        }\n\n        var replacer;\n        if (typeof replacement === 'string') {\n            replacer = function (regexMatch) {\n                var substitute = '';\n                // scan forward, copying the replacement text into the substitute string\n                // and replace any occurrence of $n with the values matched by the regex\n                var position = 0;\n                var index = replacement.indexOf('$', position);\n                while (index !== -1 && position < replacement.length) {\n                    substitute += replacement.substring(position, index);\n                    position = index + 1;\n                    var dollarVal = replacement.charAt(position);\n                    if (dollarVal === '$') {\n                        // literal $\n                        substitute += '$';\n                        position++;\n                    } else if (dollarVal === '0') {\n                        substitute += regexMatch.match;\n                        position++;\n                    } else {\n                        var maxDigits;\n                        if (regexMatch.groups.length === 0) {\n                            // no sub-matches; any $ followed by a digit will be replaced by an empty string\n                            maxDigits = 1;\n                        } else {\n                            // max number of digits to parse following the $\n                            maxDigits = Math.floor(Math.log(regexMatch.groups.length) * Math.LOG10E) + 1;\n                        }\n                        index = parseInt(replacement.substring(position, position + maxDigits), 10);\n                        if (maxDigits > 1 && index > regexMatch.groups.length) {\n                            index = parseInt(replacement.substring(position, position + maxDigits - 1), 10);\n                        }\n                        if (!isNaN(index)) {\n                            if (regexMatch.groups.length > 0) {\n                                var submatch = regexMatch.groups[index - 1];\n                                if (typeof submatch !== 'undefined') {\n                                    substitute += submatch;\n                                }\n                            }\n                            position += index.toString().length;\n                        } else {\n                            // not a capture group, treat the $ as literal\n                            substitute += '$';\n                        }\n                    }\n                    index = replacement.indexOf('$', position);\n                }\n                substitute += replacement.substring(position);\n                return substitute;\n            };\n        } else {\n            replacer = replacement;\n        }\n\n        var result = '';\n        var position = 0;\n\n        if (typeof limit === 'undefined' || limit > 0) {\n            var count = 0;\n            if (typeof pattern === 'string') {\n                var index = str.indexOf(pattern, position);\n                while (index !== -1 && (typeof limit === 'undefined' || count < limit)) {\n                    result += str.substring(position, index);\n                    result += replacement;\n                    position = index + pattern.length;\n                    count++;\n                    index = str.indexOf(pattern, position);\n                }\n                result += str.substring(position);\n            } else {\n                var matches = await evaluateMatcher(pattern, str);\n                if (typeof matches !== 'undefined') {\n                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {\n                        result += str.substring(position, matches.start);\n                        var replacedWith = replacer.apply(self, [matches]);\n                        if (isPromise(replacedWith)) {\n                            replacedWith = await replacedWith;\n                        }\n                        // check replacedWith is a string\n                        if (typeof replacedWith === 'string') {\n                            result += replacedWith;\n                        } else {\n                            // not a string - throw error\n                            throw {\n                                code: \"D3012\",\n                                stack: (new Error()).stack,\n                                value: replacedWith\n                            };\n                        }\n                        position = matches.start + matches.match.length;\n                        count++;\n                        matches = await evaluateMatcher(matches.next);\n                    }\n                    result += str.substring(position);\n                } else {\n                    result = str;\n                }\n            }\n        } else {\n            result = str;\n        }\n\n        return result;\n    }\n\n    /**\n     * Base64 encode a string\n     * @param {String} str - string\n     * @returns {String} Base 64 encoding of the binary data\n     */\n    function base64encode(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n        // Use btoa in a browser, or Buffer in Node.js\n\n        var btoa = typeof window !== 'undefined' ?\n            /* istanbul ignore next */ window.btoa :\n            function (str) {\n                // Simply doing `new Buffer` at this point causes Browserify to pull\n                // in the entire Buffer browser library, which is large and unnecessary.\n                // Using `global.Buffer` defeats this.\n                return new global.Buffer.from(str, 'binary').toString('base64'); // eslint-disable-line new-cap\n            };\n        return btoa(str);\n    }\n\n    /**\n     * Base64 decode a string\n     * @param {String} str - string\n     * @returns {String} Base 64 encoding of the binary data\n     */\n    function base64decode(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n        // Use btoa in a browser, or Buffer in Node.js\n        var atob = typeof window !== 'undefined' ?\n            /* istanbul ignore next */ window.atob :\n            function (str) {\n                // Simply doing `new Buffer` at this point causes Browserify to pull\n                // in the entire Buffer browser library, which is large and unnecessary.\n                // Using `global.Buffer` defeats this.\n                return new global.Buffer.from(str, 'base64').toString('binary'); // eslint-disable-line new-cap\n            };\n        return atob(str);\n    }\n\n    /**\n     * Encode a string into a component for a url\n     * @param {String} str - String to encode\n     * @returns {string} Encoded string\n     */\n    function encodeUrlComponent(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = encodeURIComponent(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"encodeUrlComponent\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Encode a string into a url\n     * @param {String} str - String to encode\n     * @returns {string} Encoded string\n     */\n    function encodeUrl(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = encodeURI(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"encodeUrl\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Decode a string from a component for a url\n     * @param {String} str - String to decode\n     * @returns {string} Decoded string\n     */\n    function decodeUrlComponent(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = decodeURIComponent(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"decodeUrlComponent\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Decode a string from a url\n     * @param {String} str - String to decode\n     * @returns {string} Decoded string\n     */\n    function decodeUrl(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = decodeURI(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"decodeUrl\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Split a string into an array of substrings\n     * @param {String} str - string\n     * @param {String} separator - the token or regex that splits the string\n     * @param {Integer} [limit] - max number of substrings\n     * @returns {Array} The array of string\n     */\n    async function split(str, separator, limit) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // limit, if specified, must be a non-negative number\n        if (limit < 0) {\n            throw {\n                code: \"D3020\",\n                stack: (new Error()).stack,\n                value: limit,\n                index: 3\n            };\n        }\n\n        var result = [];\n\n        if (typeof limit === 'undefined' || limit > 0) {\n            if (typeof separator === 'string') {\n                result = str.split(separator, limit);\n            } else {\n                var count = 0;\n                var matches = await evaluateMatcher(separator, str);\n                if (typeof matches !== 'undefined') {\n                    var start = 0;\n                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {\n                        result.push(str.substring(start, matches.start));\n                        start = matches.end;\n                        matches = await evaluateMatcher(matches.next);\n                        count++;\n                    }\n                    if (typeof limit === 'undefined' || count < limit) {\n                        result.push(str.substring(start));\n                    }\n                } else {\n                    result.push(str);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Join an array of strings\n     * @param {Array} strs - array of string\n     * @param {String} [separator] - the token that splits the string\n     * @returns {String} The concatenated string\n     */\n    function join(strs, separator) {\n        // undefined inputs always return undefined\n        if (typeof strs === 'undefined') {\n            return undefined;\n        }\n\n        // if separator is not specified, default to empty string\n        if (typeof separator === 'undefined') {\n            separator = \"\";\n        }\n\n        return strs.join(separator);\n    }\n\n    /**\n     * Formats a number into a decimal string representation using XPath 3.1 F&O fn:format-number spec\n     * @param {number} value - number to format\n     * @param {String} picture - picture string definition\n     * @param {Object} [options] - override locale defaults\n     * @returns {String} The formatted string\n     */\n    function formatNumber(value, picture, options) {\n        // undefined inputs always return undefined\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        var defaults = {\n            \"decimal-separator\": \".\",\n            \"grouping-separator\": \",\",\n            \"exponent-separator\": \"e\",\n            \"infinity\": \"Infinity\",\n            \"minus-sign\": \"-\",\n            \"NaN\": \"NaN\",\n            \"percent\": \"%\",\n            \"per-mille\": \"\\u2030\",\n            \"zero-digit\": \"0\",\n            \"digit\": \"#\",\n            \"pattern-separator\": \";\"\n        };\n\n        // if `options` is specified, then its entries override defaults\n        var properties = defaults;\n        if (typeof options !== 'undefined') {\n            Object.keys(options).forEach(function (key) {\n                properties[key] = options[key];\n            });\n        }\n\n        var decimalDigitFamily = [];\n        var zeroCharCode = properties['zero-digit'].charCodeAt(0);\n        for (var ii = zeroCharCode; ii < zeroCharCode + 10; ii++) {\n            decimalDigitFamily.push(String.fromCharCode(ii));\n        }\n\n        var activeChars = decimalDigitFamily.concat([properties['decimal-separator'], properties['exponent-separator'], properties['grouping-separator'], properties.digit, properties['pattern-separator']]);\n\n        var subPictures = picture.split(properties['pattern-separator']);\n\n        if (subPictures.length > 2) {\n            throw {\n                code: 'D3080',\n                stack: (new Error()).stack\n            };\n        }\n\n        var splitParts = function (subpicture) {\n            var prefix = (function () {\n                var ch;\n                for (var ii = 0; ii < subpicture.length; ii++) {\n                    ch = subpicture.charAt(ii);\n                    if (activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {\n                        return subpicture.substring(0, ii);\n                    }\n                }\n            })();\n            var suffix = (function () {\n                var ch;\n                for (var ii = subpicture.length - 1; ii >= 0; ii--) {\n                    ch = subpicture.charAt(ii);\n                    if (activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {\n                        return subpicture.substring(ii + 1);\n                    }\n                }\n            })();\n            var activePart = subpicture.substring(prefix.length, subpicture.length - suffix.length);\n            var mantissaPart, exponentPart, integerPart, fractionalPart;\n            var exponentPosition = subpicture.indexOf(properties['exponent-separator'], prefix.length);\n            if (exponentPosition === -1 || exponentPosition > subpicture.length - suffix.length) {\n                mantissaPart = activePart;\n                exponentPart = undefined;\n            } else {\n                mantissaPart = activePart.substring(0, exponentPosition);\n                exponentPart = activePart.substring(exponentPosition + 1);\n            }\n            var decimalPosition = mantissaPart.indexOf(properties['decimal-separator']);\n            if (decimalPosition === -1) {\n                integerPart = mantissaPart;\n                fractionalPart = suffix;\n            } else {\n                integerPart = mantissaPart.substring(0, decimalPosition);\n                fractionalPart = mantissaPart.substring(decimalPosition + 1);\n            }\n            return {\n                prefix: prefix,\n                suffix: suffix,\n                activePart: activePart,\n                mantissaPart: mantissaPart,\n                exponentPart: exponentPart,\n                integerPart: integerPart,\n                fractionalPart: fractionalPart,\n                subpicture: subpicture\n            };\n        };\n\n        // validate the picture string, F&O 4.7.3\n        var validate = function (parts) {\n            var error;\n            var ii;\n            var subpicture = parts.subpicture;\n            var decimalPos = subpicture.indexOf(properties['decimal-separator']);\n            if (decimalPos !== subpicture.lastIndexOf(properties['decimal-separator'])) {\n                error = 'D3081';\n            }\n            if (subpicture.indexOf(properties.percent) !== subpicture.lastIndexOf(properties.percent)) {\n                error = 'D3082';\n            }\n            if (subpicture.indexOf(properties['per-mille']) !== subpicture.lastIndexOf(properties['per-mille'])) {\n                error = 'D3083';\n            }\n            if (subpicture.indexOf(properties.percent) !== -1 && subpicture.indexOf(properties['per-mille']) !== -1) {\n                error = 'D3084';\n            }\n            var valid = false;\n            for (ii = 0; ii < parts.mantissaPart.length; ii++) {\n                var ch = parts.mantissaPart.charAt(ii);\n                if (decimalDigitFamily.indexOf(ch) !== -1 || ch === properties.digit) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (!valid) {\n                error = 'D3085';\n            }\n            var charTypes = parts.activePart.split('').map(function (char) {\n                return activeChars.indexOf(char) === -1 ? 'p' : 'a';\n            }).join('');\n            if (charTypes.indexOf('p') !== -1) {\n                error = 'D3086';\n            }\n            if (decimalPos !== -1) {\n                if (subpicture.charAt(decimalPos - 1) === properties['grouping-separator'] || subpicture.charAt(decimalPos + 1) === properties['grouping-separator']) {\n                    error = 'D3087';\n                }\n            } else if (parts.integerPart.charAt(parts.integerPart.length - 1) === properties['grouping-separator']) {\n                error = 'D3088';\n            }\n            if (subpicture.indexOf(properties['grouping-separator'] + properties['grouping-separator']) !== -1) {\n                error = 'D3089';\n            }\n            var optionalDigitPos = parts.integerPart.indexOf(properties.digit);\n            if (optionalDigitPos !== -1 && parts.integerPart.substring(0, optionalDigitPos).split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) > -1;\n            }).length > 0) {\n                error = 'D3090';\n            }\n            optionalDigitPos = parts.fractionalPart.lastIndexOf(properties.digit);\n            if (optionalDigitPos !== -1 && parts.fractionalPart.substring(optionalDigitPos).split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) > -1;\n            }).length > 0) {\n                error = 'D3091';\n            }\n            var exponentExists = (typeof parts.exponentPart === 'string');\n            if (exponentExists && parts.exponentPart.length > 0 && (subpicture.indexOf(properties.percent) !== -1 || subpicture.indexOf(properties['per-mille']) !== -1)) {\n                error = 'D3092';\n            }\n            if (exponentExists && (parts.exponentPart.length === 0 || parts.exponentPart.split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) === -1;\n            }).length > 0)) {\n                error = 'D3093';\n            }\n            if (error) {\n                throw {\n                    code: error,\n                    stack: (new Error()).stack\n                };\n            }\n        };\n\n        // analyse the picture string, F&O 4.7.4\n        var analyse = function (parts) {\n            var getGroupingPositions = function (part, toLeft) {\n                var positions = [];\n                var groupingPosition = part.indexOf(properties['grouping-separator']);\n                while (groupingPosition !== -1) {\n                    var charsToTheRight = (toLeft ? part.substring(0, groupingPosition) : part.substring(groupingPosition)).split('').filter(function (char) {\n                        return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;\n                    }).length;\n                    positions.push(charsToTheRight);\n                    groupingPosition = parts.integerPart.indexOf(properties['grouping-separator'], groupingPosition + 1);\n                }\n                return positions;\n            };\n            var integerPartGroupingPositions = getGroupingPositions(parts.integerPart);\n            var regular = function (indexes) {\n                // are the grouping positions regular? i.e. same interval between each of them\n                if (indexes.length === 0) {\n                    return 0;\n                }\n                var gcd = function (a, b) {\n                    return b === 0 ? a : gcd(b, a % b);\n                };\n                // find the greatest common divisor of all the positions\n                var factor = indexes.reduce(gcd);\n                // is every position separated by this divisor? If so, it's regular\n                for (var index = 1; index <= indexes.length; index++) {\n                    if (indexes.indexOf(index * factor) === -1) {\n                        return 0;\n                    }\n                }\n                return factor;\n            };\n\n            var regularGrouping = regular(integerPartGroupingPositions);\n            var fractionalPartGroupingPositions = getGroupingPositions(parts.fractionalPart, true);\n\n            var minimumIntegerPartSize = parts.integerPart.split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) !== -1;\n            }).length;\n            var scalingFactor = minimumIntegerPartSize;\n\n            var fractionalPartArray = parts.fractionalPart.split('');\n            var minimumFactionalPartSize = fractionalPartArray.filter(function (char) {\n                return decimalDigitFamily.indexOf(char) !== -1;\n            }).length;\n            var maximumFactionalPartSize = fractionalPartArray.filter(function (char) {\n                return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;\n            }).length;\n            var exponentPresent = typeof parts.exponentPart === 'string';\n            if (minimumIntegerPartSize === 0 && maximumFactionalPartSize === 0) {\n                if (exponentPresent) {\n                    minimumFactionalPartSize = 1;\n                    maximumFactionalPartSize = 1;\n                } else {\n                    minimumIntegerPartSize = 1;\n                }\n            }\n            if (exponentPresent && minimumIntegerPartSize === 0 && parts.integerPart.indexOf(properties.digit) !== -1) {\n                minimumIntegerPartSize = 1;\n            }\n            if (minimumIntegerPartSize === 0 && minimumFactionalPartSize === 0) {\n                minimumFactionalPartSize = 1;\n            }\n            var minimumExponentSize = 0;\n            if (exponentPresent) {\n                minimumExponentSize = parts.exponentPart.split('').filter(function (char) {\n                    return decimalDigitFamily.indexOf(char) !== -1;\n                }).length;\n            }\n\n            return {\n                integerPartGroupingPositions: integerPartGroupingPositions,\n                regularGrouping: regularGrouping,\n                minimumIntegerPartSize: minimumIntegerPartSize,\n                scalingFactor: scalingFactor,\n                prefix: parts.prefix,\n                fractionalPartGroupingPositions: fractionalPartGroupingPositions,\n                minimumFactionalPartSize: minimumFactionalPartSize,\n                maximumFactionalPartSize: maximumFactionalPartSize,\n                minimumExponentSize: minimumExponentSize,\n                suffix: parts.suffix,\n                picture: parts.subpicture\n            };\n        };\n\n        var parts = subPictures.map(splitParts);\n        parts.forEach(validate);\n\n        var variables = parts.map(analyse);\n\n        var minus_sign = properties['minus-sign'];\n        var zero_digit = properties['zero-digit'];\n        var decimal_separator = properties['decimal-separator'];\n        var grouping_separator = properties['grouping-separator'];\n\n        if (variables.length === 1) {\n            variables.push(JSON.parse(JSON.stringify(variables[0])));\n            variables[1].prefix = minus_sign + variables[1].prefix;\n        }\n\n        // TODO cache the result of the analysis\n\n        // format the number\n        // bullet 1: TODO: NaN - not sure we'd ever get this in JSON\n        var pic;\n        // bullet 2:\n        if (value >= 0) {\n            pic = variables[0];\n        } else {\n            pic = variables[1];\n        }\n        var adjustedNumber;\n        // bullet 3:\n        if (pic.picture.indexOf(properties.percent) !== -1) {\n            adjustedNumber = value * 100;\n        } else if (pic.picture.indexOf(properties['per-mille']) !== -1) {\n            adjustedNumber = value * 1000;\n        } else {\n            adjustedNumber = value;\n        }\n        // bullet 4:\n        // TODO: infinity - not sure we'd ever get this in JSON\n        // bullet 5:\n        var mantissa, exponent;\n        if (pic.minimumExponentSize === 0) {\n            mantissa = adjustedNumber;\n        } else {\n            // mantissa * 10^exponent = adjustedNumber\n            var maxMantissa = Math.pow(10, pic.scalingFactor);\n            var minMantissa = Math.pow(10, pic.scalingFactor - 1);\n            mantissa = adjustedNumber;\n            exponent = 0;\n            while (mantissa < minMantissa) {\n                mantissa *= 10;\n                exponent -= 1;\n            }\n            while (mantissa > maxMantissa) {\n                mantissa /= 10;\n                exponent += 1;\n            }\n        }\n        // bullet 6:\n        var roundedNumber = round(mantissa, pic.maximumFactionalPartSize);\n        // bullet 7:\n        var makeString = function (value, dp) {\n            var str = Math.abs(value).toFixed(dp);\n            if (zero_digit !== '0') {\n                str = str.split('').map(function (digit) {\n                    if (digit >= '0' && digit <= '9') {\n                        return decimalDigitFamily[digit.charCodeAt(0) - 48];\n                    } else {\n                        return digit;\n                    }\n                }).join('');\n            }\n            return str;\n        };\n        var stringValue = makeString(roundedNumber, pic.maximumFactionalPartSize);\n        var decimalPos = stringValue.indexOf('.');\n        if (decimalPos === -1) {\n            stringValue = stringValue + decimal_separator;\n        } else {\n            stringValue = stringValue.replace('.', decimal_separator);\n        }\n        while (stringValue.charAt(0) === zero_digit) {\n            stringValue = stringValue.substring(1);\n        }\n        while (stringValue.charAt(stringValue.length - 1) === zero_digit) {\n            stringValue = stringValue.substring(0, stringValue.length - 1);\n        }\n        // bullets 8 & 9:\n        decimalPos = stringValue.indexOf(decimal_separator);\n        var padLeft = pic.minimumIntegerPartSize - decimalPos;\n        var padRight = pic.minimumFactionalPartSize - (stringValue.length - decimalPos - 1);\n        stringValue = (padLeft > 0 ? new Array(padLeft + 1).join(zero_digit) : '') + stringValue;\n        stringValue = stringValue + (padRight > 0 ? new Array(padRight + 1).join(zero_digit) : '');\n        decimalPos = stringValue.indexOf(decimal_separator);\n        // bullet 10:\n        if (pic.regularGrouping > 0) {\n            var groupCount = Math.floor((decimalPos - 1) / pic.regularGrouping);\n            for (var group = 1; group <= groupCount; group++) {\n                stringValue = [stringValue.slice(0, decimalPos - group * pic.regularGrouping), grouping_separator, stringValue.slice(decimalPos - group * pic.regularGrouping)].join('');\n            }\n        } else {\n            pic.integerPartGroupingPositions.forEach(function (pos) {\n                stringValue = [stringValue.slice(0, decimalPos - pos), grouping_separator, stringValue.slice(decimalPos - pos)].join('');\n                decimalPos++;\n            });\n        }\n        // bullet 11:\n        decimalPos = stringValue.indexOf(decimal_separator);\n        pic.fractionalPartGroupingPositions.forEach(function (pos) {\n            stringValue = [stringValue.slice(0, pos + decimalPos + 1), grouping_separator, stringValue.slice(pos + decimalPos + 1)].join('');\n        });\n        // bullet 12:\n        decimalPos = stringValue.indexOf(decimal_separator);\n        if (pic.picture.indexOf(decimal_separator) === -1 || decimalPos === stringValue.length - 1) {\n            stringValue = stringValue.substring(0, stringValue.length - 1);\n        }\n        // bullet 13:\n        if (typeof exponent !== 'undefined') {\n            var stringExponent = makeString(exponent, 0);\n            padLeft = pic.minimumExponentSize - stringExponent.length;\n            if (padLeft > 0) {\n                stringExponent = new Array(padLeft + 1).join(zero_digit) + stringExponent;\n            }\n            stringValue = stringValue + properties['exponent-separator'] + (exponent < 0 ? minus_sign : '') + stringExponent;\n        }\n        // bullet 14:\n        stringValue = pic.prefix + stringValue + pic.suffix;\n        return stringValue;\n    }\n\n    /**\n     * Converts a number to a string using a specified number base\n     * @param {number} value - the number to convert\n     * @param {number} [radix] - the number base; must be between 2 and 36. Defaults to 10\n     * @returns {string} - the converted string\n     */\n    function formatBase(value, radix) {\n        // undefined inputs always return undefined\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        value = round(value);\n\n        if (typeof radix === 'undefined') {\n            radix = 10;\n        } else {\n            radix = round(radix);\n        }\n\n        if (radix < 2 || radix > 36) {\n            throw {\n                code: 'D3100',\n                stack: (new Error()).stack,\n                value: radix\n            };\n\n        }\n\n        var result = value.toString(radix);\n\n        return result;\n    }\n\n    /**\n     * Cast argument to number\n     * @param {Object} arg - Argument\n     * @returns {Number} numeric value of argument\n     */\n    function number(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        if (typeof arg === 'number') {\n            // already a number\n            result = arg;\n        } else if (typeof arg === 'string' && /^-?[0-9]+(\\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(arg) && !isNaN(parseFloat(arg)) && isFinite(arg)) {\n            result = parseFloat(arg);\n        } else if (typeof arg === 'string' && /^(0[xX][0-9A-Fa-f]+)|(0[oO][0-7]+)|(0[bB][0-1]+)$/.test(arg)) {\n            result = Number(arg);\n        } else if (arg === true) {\n            // boolean true casts to 1\n            result = 1;\n        } else if (arg === false) {\n            // boolean false casts to 0\n            result = 0;\n        } else {\n            throw {\n                code: \"D3030\",\n                value: arg,\n                stack: (new Error()).stack,\n                index: 1\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Absolute value of a number\n     * @param {Number} arg - Argument\n     * @returns {Number} absolute value of argument\n     */\n    function abs(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.abs(arg);\n        return result;\n    }\n\n    /**\n     * Rounds a number down to integer\n     * @param {Number} arg - Argument\n     * @returns {Number} rounded integer\n     */\n    function floor(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.floor(arg);\n        return result;\n    }\n\n    /**\n     * Rounds a number up to integer\n     * @param {Number} arg - Argument\n     * @returns {Number} rounded integer\n     */\n    function ceil(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.ceil(arg);\n        return result;\n    }\n\n    /**\n     * Round to half even\n     * @param {Number} arg - Argument\n     * @param {Number} [precision] - number of decimal places\n     * @returns {Number} rounded integer\n     */\n    function round(arg, precision) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        if (precision) {\n            // shift the decimal place - this needs to be done in a string since multiplying\n            // by a power of ten can introduce floating point precision errors which mess up\n            // this rounding algorithm - See 'Decimal rounding' in\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n            // Shift\n            var value = arg.toString().split('e');\n            arg = +(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision));\n\n        }\n\n        // round up to nearest int\n        result = Math.round(arg);\n        var diff = result - arg;\n        if (Math.abs(diff) === 0.5 && Math.abs(result % 2) === 1) {\n            // rounded the wrong way - adjust to nearest even number\n            result = result - 1;\n        }\n        if (precision) {\n            // Shift back\n            value = result.toString().split('e');\n            /* istanbul ignore next */\n            result = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));\n        }\n        if (Object.is(result, -0)) { // ESLint rule 'no-compare-neg-zero' suggests this way\n            // JSON doesn't do -0\n            result = 0;\n        }\n        return result;\n    }\n\n    /**\n     * Square root of number\n     * @param {Number} arg - Argument\n     * @returns {Number} square root\n     */\n    function sqrt(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        if (arg < 0) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3060\",\n                index: 1,\n                value: arg\n            };\n        }\n\n        result = Math.sqrt(arg);\n\n        return result;\n    }\n\n    /**\n     * Raises number to the power of the second number\n     * @param {Number} arg - the base\n     * @param {Number} exp - the exponent\n     * @returns {Number} rounded integer\n     */\n    function power(arg, exp) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.pow(arg, exp);\n\n        if (!isFinite(result)) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3061\",\n                index: 1,\n                value: arg,\n                exp: exp\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns a random number 0 <= n < 1\n     * @returns {number} random number\n     */\n    function random() {\n        return Math.random();\n    }\n\n    /**\n     * Evaluate an input and return a boolean\n     * @param {*} arg - Arguments\n     * @returns {boolean} Boolean\n     */\n    function boolean(arg) {\n        // cast arg to its effective boolean value\n        // boolean: unchanged\n        // string: zero-length -> false; otherwise -> true\n        // number: 0 -> false; otherwise -> true\n        // null -> false\n        // array: empty -> false; length > 1 -> true\n        // object: empty -> false; non-empty -> true\n        // function -> false\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        var result = false;\n        if (Array.isArray(arg)) {\n            if (arg.length === 1) {\n                result = boolean(arg[0]);\n            } else if (arg.length > 1) {\n                var trues = arg.filter(function (val) {\n                    return boolean(val);\n                });\n                result = trues.length > 0;\n            }\n        } else if (typeof arg === 'string') {\n            if (arg.length > 0) {\n                result = true;\n            }\n        } else if (isNumeric(arg)) {\n            if (arg !== 0) {\n                result = true;\n            }\n        } else if (arg !== null && typeof arg === 'object') {\n            if (Object.keys(arg).length > 0) {\n                result = true;\n            }\n        } else if (typeof arg === 'boolean' && arg === true) {\n            result = true;\n        }\n        return result;\n    }\n\n    /**\n     * returns the Boolean NOT of the arg\n     * @param {*} arg - argument\n     * @returns {boolean} - NOT arg\n     */\n    function not(arg) {\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        return !boolean(arg);\n    }\n\n    /**\n     * Helper function to build the arguments to be supplied to the function arg of the\n     * HOFs map, filter, each, sift and single\n     * @param {function} func - the function to be invoked\n     * @param {*} arg1 - the first (required) arg - the value\n     * @param {*} arg2 - the second (optional) arg - the position (index or key)\n     * @param {*} arg3 - the third (optional) arg - the whole structure (array or object)\n     * @returns {*[]} the argument list\n     */\n    function hofFuncArgs(func, arg1, arg2, arg3) {\n        var func_args = [arg1]; // the first arg (the value) is required\n        // the other two are optional - only supply it if the function can take it\n        var length = getFunctionArity(func);\n        if (length >= 2) {\n            func_args.push(arg2);\n        }\n        if (length >= 3) {\n            func_args.push(arg3);\n        }\n        return func_args;\n    }\n\n    /**\n     * Create a map from an array of arguments\n     * @param {Array} [arr] - array to map over\n     * @param {Function} func - function to apply\n     * @returns {Array} Map array\n     */\n    async function map(arr, func) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        var result = createSequence();\n        // do the map - iterate over the arrays, and invoke func\n        for (var i = 0; i < arr.length; i++) {\n            var func_args = hofFuncArgs(func, arr[i], i, arr);\n            // invoke func\n            var res = await func.apply(this, func_args);\n            if (typeof res !== 'undefined') {\n                result.push(res);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a map from an array of arguments\n     * @param {Array} [arr] - array to filter\n     * @param {Function} func - predicate function\n     * @returns {Array} Map array\n     */\n    async function filter(arr, func) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        var result = createSequence();\n\n        for (var i = 0; i < arr.length; i++) {\n            var entry = arr[i];\n            var func_args = hofFuncArgs(func, entry, i, arr);\n            // invoke func\n            var res = await func.apply(this, func_args);\n            if (boolean(res)) {\n                result.push(entry);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Given an array, find the single element matching a specified condition\n     * Throws an exception if the number of matching elements is not exactly one\n     * @param {Array} [arr] - array to filter\n     * @param {Function} [func] - predicate function\n     * @returns {*} Matching element\n     */\n    async function single(arr, func) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        var hasFoundMatch = false;\n        var result;\n\n        for (var i = 0; i < arr.length; i++) {\n            var entry = arr[i];\n            var positiveResult = true;\n            if (typeof func !== 'undefined') {\n                var func_args = hofFuncArgs(func, entry, i, arr);\n                // invoke func\n                var res = await func.apply(this, func_args);\n                positiveResult = boolean(res);\n            }\n            if (positiveResult) {\n                if(!hasFoundMatch) {\n                    result = entry;\n                    hasFoundMatch = true;\n                } else {\n                    throw {\n                        stack: (new Error()).stack,\n                        code: \"D3138\",\n                        index: i\n                    };\n                }\n            }\n        }\n\n        if(!hasFoundMatch) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3139\"\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     * Convolves (zips) each value from a set of arrays\n     * @param {Array} [args] - arrays to zip\n     * @returns {Array} Zipped array\n     */\n    function zip() {\n        // this can take a variable number of arguments\n        var result = [];\n        var args = Array.prototype.slice.call(arguments);\n        // length of the shortest array\n        var length = Math.min.apply(Math, args.map(function (arg) {\n            if (Array.isArray(arg)) {\n                return arg.length;\n            }\n            return 0;\n        }));\n        for (var i = 0; i < length; i++) {\n            var tuple = args.map((arg) => {\n                return arg[i];\n            });\n            result.push(tuple);\n        }\n        return result;\n    }\n\n    /**\n     * Fold left function\n     * @param {Array} sequence - Sequence\n     * @param {Function} func - Function\n     * @param {Object} init - Initial value\n     * @returns {*} Result\n     */\n    async function foldLeft(sequence, func, init) {\n        // undefined inputs always return undefined\n        if (typeof sequence === 'undefined') {\n            return undefined;\n        }\n\n        var result;\n\n        var arity = getFunctionArity(func);\n        if (arity < 2) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3050\",\n                index: 1\n            };\n        }\n\n        var index;\n        if (typeof init === 'undefined' && sequence.length > 0) {\n            result = sequence[0];\n            index = 1;\n        } else {\n            result = init;\n            index = 0;\n        }\n\n        while (index < sequence.length) {\n            var args = [result, sequence[index]];\n            if (arity >= 3) {\n                args.push(index);\n            }\n            if (arity >= 4) {\n                args.push(sequence);\n            }\n            result = await func.apply(this, args);\n            index++;\n        }\n\n        return result;\n    }\n\n    /**\n     * Return keys for an object\n     * @param {Object} arg - Object\n     * @returns {Array} Array of keys\n     */\n    function keys(arg) {\n        var result = createSequence();\n\n        if (Array.isArray(arg)) {\n            // merge the keys of all of the items in the array\n            var merge = {};\n            arg.forEach(function (item) {\n                var allkeys = keys(item);\n                allkeys.forEach(function (key) {\n                    merge[key] = true;\n                });\n            });\n            result = keys(merge);\n        } else if (arg !== null && typeof arg === 'object' && !isFunction(arg)) {\n            Object.keys(arg).forEach(key => result.push(key));\n        }\n        return result;\n    }\n\n    /**\n     * Return value from an object for a given key\n     * @param {Object} input - Object/Array\n     * @param {String} key - Key in object\n     * @returns {*} Value of key in object\n     */\n    function lookup(input, key) {\n        // lookup the 'name' item in the input\n        var result;\n        if (Array.isArray(input)) {\n            result = createSequence();\n            for(var ii = 0; ii < input.length; ii++) {\n                var res =  lookup(input[ii], key);\n                if (typeof res !== 'undefined') {\n                    if (Array.isArray(res)) {\n                        res.forEach(val => result.push(val));\n                    } else {\n                        result.push(res);\n                    }\n                }\n            }\n        } else if (input !== null && typeof input === 'object' && !isFunction(input)) {\n            result = input[key];\n        }\n        return result;\n    }\n\n    /**\n     * Append second argument to first\n     * @param {Array|Object} arg1 - First argument\n     * @param {Array|Object} arg2 - Second argument\n     * @returns {*} Appended arguments\n     */\n    function append(arg1, arg2) {\n        // disregard undefined args\n        if (typeof arg1 === 'undefined') {\n            return arg2;\n        }\n        if (typeof arg2 === 'undefined') {\n            return arg1;\n        }\n        // if either argument is not an array, make it so\n        if (!Array.isArray(arg1)) {\n            arg1 = createSequence(arg1);\n        }\n        if (!Array.isArray(arg2)) {\n            arg2 = [arg2];\n        }\n        return arg1.concat(arg2);\n    }\n\n    /**\n     * Determines if the argument is undefined\n     * @param {*} arg - argument\n     * @returns {boolean} False if argument undefined, otherwise true\n     */\n    function exists(arg) {\n        if (typeof arg === 'undefined') {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Splits an object into an array of object with one property each\n     * @param {*} arg - the object to split\n     * @returns {*} - the array\n     */\n    function spread(arg) {\n        var result = createSequence();\n\n        if (Array.isArray(arg)) {\n            // spread all of the items in the array\n            arg.forEach(function (item) {\n                result = append(result, spread(item));\n            });\n        } else if (arg !== null && typeof arg === 'object' && !isLambda(arg)) {\n            for (var key in arg) {\n                var obj = {};\n                obj[key] = arg[key];\n                result.push(obj);\n            }\n        } else {\n            result = arg;\n        }\n        return result;\n    }\n\n    /**\n     * Merges an array of objects into a single object.  Duplicate properties are\n     * overridden by entries later in the array\n     * @param {*} arg - the objects to merge\n     * @returns {*} - the object\n     */\n    function merge(arg) {\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        var result = {};\n\n        arg.forEach(function (obj) {\n            for (var prop in obj) {\n                result[prop] = obj[prop];\n            }\n        });\n        return result;\n    }\n\n    /**\n     * Reverses the order of items in an array\n     * @param {Array} arr - the array to reverse\n     * @returns {Array} - the reversed array\n     */\n    function reverse(arr) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if (arr.length <= 1) {\n            return arr;\n        }\n\n        var length = arr.length;\n        var result = new Array(length);\n        for (var i = 0; i < length; i++) {\n            result[length - i - 1] = arr[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {*} obj - the input object to iterate over\n     * @param {*} func - the function to apply to each key/value pair\n     * @returns {Array} - the resultant array\n     */\n    async function each(obj, func) {\n        var result = createSequence();\n\n        for (var key in obj) {\n            var func_args = hofFuncArgs(func, obj[key], key, obj);\n            // invoke func\n            var val = await func.apply(this, func_args);\n            if(typeof val !== 'undefined') {\n                result.push(val);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {string} [message] - the message to attach to the error\n     * @throws custom error with code 'D3137'\n     */\n    function error(message) {\n        throw {\n            code: \"D3137\",\n            stack: (new Error()).stack,\n            message: message || \"$error() function evaluated\"\n        };\n    }\n\n    /**\n     *\n     * @param {boolean} condition - the condition to evaluate\n     * @param {string} [message] - the message to attach to the error\n     * @throws custom error with code 'D3137'\n     * @returns {undefined}\n     */\n    function assert(condition, message) {\n        if(!condition) {\n            throw {\n                code: \"D3141\",\n                stack: (new Error()).stack,\n                message: message || \"$assert() statement failed\"\n            };\n        }\n\n        return undefined;\n    }\n\n    /**\n     *\n     * @param {*} [value] - the input to which the type will be checked\n     * @returns {string} - the type of the input\n     */\n    function type(value) {\n        if (value === undefined) {\n            return undefined;\n        }\n\n        if (value === null) {\n            return 'null';\n        }\n\n        if (isNumeric(value)) {\n            return 'number';\n        }\n\n        if (typeof value === 'string') {\n            return 'string';\n        }\n\n        if (typeof value === 'boolean') {\n            return 'boolean';\n        }\n\n        if(Array.isArray(value)) {\n            return 'array';\n        }\n\n        if(isFunction(value)) {\n            return 'function';\n        }\n\n        return 'object';\n    }\n\n    /**\n     * Implements the merge sort (stable) with optional comparator function\n     *\n     * @param {Array} arr - the array to sort\n     * @param {*} comparator - comparator function\n     * @returns {Array} - sorted array\n     */\n    async function sort(arr, comparator) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if (arr.length <= 1) {\n            return arr;\n        }\n\n        var comp;\n        if (typeof comparator === 'undefined') {\n            // inject a default comparator - only works for numeric or string arrays\n            if (!isArrayOfNumbers(arr) && !isArrayOfStrings(arr)) {\n                throw {\n                    stack: (new Error()).stack,\n                    code: \"D3070\",\n                    index: 1\n                };\n            }\n\n            comp = async function (a, b) {\n                return a > b;\n            };\n        } else {\n            // for internal usage of functionSort (i.e. order-by syntax)\n            comp = comparator;\n        }\n\n        var merge = async function (l, r) {\n            var merge_iter = async function (result, left, right) {\n                if (left.length === 0) {\n                    Array.prototype.push.apply(result, right);\n                } else if (right.length === 0) {\n                    Array.prototype.push.apply(result, left);\n                } else if (await comp(left[0], right[0])) { // invoke the comparator function\n                    // if it returns true - swap left and right\n                    result.push(right[0]);\n                    await merge_iter(result, left, right.slice(1));\n                } else {\n                    // otherwise keep the same order\n                    result.push(left[0]);\n                    await merge_iter(result, left.slice(1), right);\n                }\n            };\n            var merged = [];\n            await merge_iter(merged, l, r);\n            return merged;\n        };\n\n        var msort = async function (array) {\n            if (!Array.isArray(array) || array.length <= 1) {\n                return array;\n            } else {\n                var middle = Math.floor(array.length / 2);\n                var left = array.slice(0, middle);\n                var right = array.slice(middle);\n                left = await msort(left);\n                right = await msort(right);\n                return await merge(left, right);\n            }\n        };\n\n        var result = await msort(arr);\n\n        return result;\n    }\n\n    /**\n     * Randomly shuffles the contents of an array\n     * @param {Array} arr - the input array\n     * @returns {Array} the shuffled array\n     */\n    function shuffle(arr) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if (arr.length <= 1) {\n            return arr;\n        }\n\n        // shuffle using the 'inside-out' variant of the Fisher-Yates algorithm\n        var result = new Array(arr.length);\n        for (var i = 0; i < arr.length; i++) {\n            var j = Math.floor(Math.random() * (i + 1)); // random integer such that 0  j  i\n            if (i !== j) {\n                result[i] = result[j];\n            }\n            result[j] = arr[i];\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the values that appear in a sequence, with duplicates eliminated.\n     * @param {Array} arr - An array or sequence of values\n     * @returns {Array} - sequence of distinct values\n     */\n    function distinct(arr) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if(!Array.isArray(arr) || arr.length <= 1) {\n            return arr;\n        }\n\n        var results = isSequence(arr) ? createSequence() : [];\n\n        for(var ii = 0; ii < arr.length; ii++) {\n            var value = arr[ii];\n            // is this value already in the result sequence?\n            var includes = false;\n            for(var jj = 0; jj < results.length; jj++) {\n                if (deepEquals(value, results[jj])) {\n                    includes = true;\n                    break;\n                }\n            }\n            if(!includes) {\n                results.push(value);\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Applies a predicate function to each key/value pair in an object, and returns an object containing\n     * only the key/value pairs that passed the predicate\n     *\n     * @param {object} arg - the object to be sifted\n     * @param {object} func - the predicate function (lambda or native)\n     * @returns {object} - sifted object\n     */\n    async function sift(arg, func) {\n        var result = {};\n\n        for (var item in arg) {\n            var entry = arg[item];\n            var func_args = hofFuncArgs(func, entry, item, arg);\n            // invoke func\n            var res = await func.apply(this, func_args);\n            if (boolean(res)) {\n                result[item] = entry;\n            }\n        }\n\n        // empty objects should be changed to undefined\n        if (Object.keys(result).length === 0) {\n            result = undefined;\n        }\n\n        return result;\n    }\n\n    return {\n        sum, count, max, min, average,\n        string, substring, substringBefore, substringAfter, lowercase, uppercase, length, trim, pad,\n        match, contains, replace, split, join,\n        formatNumber, formatBase, number, floor, ceil, round, abs, sqrt, power, random,\n        boolean, not,\n        map, zip, filter, single, foldLeft, sift,\n        keys, lookup, append, exists, spread, merge, reverse, each, error, assert, type, sort, shuffle, distinct,\n        base64encode, base64decode,  encodeUrlComponent, encodeUrl, decodeUrlComponent, decodeUrl\n    };\n})();\n\nmodule.exports = functions;\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./utils\":6}],3:[function(require,module,exports){\n/**\n *  Copyright IBM Corp. 2016, 2017 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\n/**\n * @module JSONata\n * @description JSON query and transformation language\n */\n\nvar datetime = require('./datetime');\nvar fn = require('./functions');\nvar utils = require('./utils');\nvar parser = require('./parser');\nvar parseSignature = require('./signature');\n\n/**\n * jsonata\n * @function\n * @param {Object} expr - JSONata expression\n * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression\n */\nvar jsonata = (function() {\n    'use strict';\n\n    var isNumeric = utils.isNumeric;\n    var isArrayOfStrings = utils.isArrayOfStrings;\n    var isArrayOfNumbers = utils.isArrayOfNumbers;\n    var createSequence = utils.createSequence;\n    var isSequence = utils.isSequence;\n    var isFunction = utils.isFunction;\n    var isLambda = utils.isLambda;\n    var isIterable = utils.isIterable;\n    var isPromise = utils.isPromise;\n    var getFunctionArity = utils.getFunctionArity;\n    var isDeepEqual = utils.isDeepEqual;\n\n    // Start of Evaluator code\n\n    var staticFrame = createFrame(null);\n\n    /**\n     * Evaluate expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluate(expr, input, environment) {\n        var result;\n\n        var entryCallback = environment.lookup(Symbol.for('jsonata.__evaluate_entry'));\n        if(entryCallback) {\n            await entryCallback(expr, input, environment);\n        }\n\n        switch (expr.type) {\n            case 'path':\n                result = await evaluatePath(expr, input, environment);\n                break;\n            case 'binary':\n                result = await evaluateBinary(expr, input, environment);\n                break;\n            case 'unary':\n                result = await evaluateUnary(expr, input, environment);\n                break;\n            case 'name':\n                result = evaluateName(expr, input, environment);\n                break;\n            case 'string':\n            case 'number':\n            case 'value':\n                result = evaluateLiteral(expr, input, environment);\n                break;\n            case 'wildcard':\n                result = evaluateWildcard(expr, input, environment);\n                break;\n            case 'descendant':\n                result = evaluateDescendants(expr, input, environment);\n                break;\n            case 'parent':\n                result = environment.lookup(expr.slot.label);\n                break;\n            case 'condition':\n                result = await evaluateCondition(expr, input, environment);\n                break;\n            case 'block':\n                result = await evaluateBlock(expr, input, environment);\n                break;\n            case 'bind':\n                result = await evaluateBindExpression(expr, input, environment);\n                break;\n            case 'regex':\n                result = evaluateRegex(expr, input, environment);\n                break;\n            case 'function':\n                result = await evaluateFunction(expr, input, environment);\n                break;\n            case 'variable':\n                result = evaluateVariable(expr, input, environment);\n                break;\n            case 'lambda':\n                result = evaluateLambda(expr, input, environment);\n                break;\n            case 'partial':\n                result = await evaluatePartialApplication(expr, input, environment);\n                break;\n            case 'apply':\n                result = await evaluateApplyExpression(expr, input, environment);\n                break;\n            case 'transform':\n                result = evaluateTransformExpression(expr, input, environment);\n                break;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(expr, 'predicate')) {\n            for(var ii = 0; ii < expr.predicate.length; ii++) {\n                result = await evaluateFilter(expr.predicate[ii].expr, result, environment);\n            }\n        }\n\n        if (expr.type !== 'path' && Object.prototype.hasOwnProperty.call(expr, 'group')) {\n            result = await evaluateGroupExpression(expr.group, result, environment);\n        }\n\n        var exitCallback = environment.lookup(Symbol.for('jsonata.__evaluate_exit'));\n        if(exitCallback) {\n            await exitCallback(expr, input, environment, result);\n        }\n\n        if(result && isSequence(result) && !result.tupleStream) {\n            if(expr.keepArray) {\n                result.keepSingleton = true;\n            }\n            if(result.length === 0) {\n                result = undefined;\n            } else if(result.length === 1) {\n                result =  result.keepSingleton ? result : result[0];\n            }\n\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate path expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluatePath(expr, input, environment) {\n        var inputSequence;\n        // expr is an array of steps\n        // if the first step is a variable reference ($...), including root reference ($$),\n        //   then the path is absolute rather than relative\n        if (Array.isArray(input) && expr.steps[0].type !== 'variable') {\n            inputSequence = input;\n        } else {\n            // if input is not an array, make it so\n            inputSequence = createSequence(input);\n        }\n\n        var resultSequence;\n        var isTupleStream = false;\n        var tupleBindings = undefined;\n\n        // evaluate each step in turn\n        for(var ii = 0; ii < expr.steps.length; ii++) {\n            var step = expr.steps[ii];\n\n            if(step.tuple) {\n                isTupleStream = true;\n            }\n\n            // if the first step is an explicit array constructor, then just evaluate that (i.e. don't iterate over a context array)\n            if(ii === 0 && step.consarray) {\n                resultSequence = await evaluate(step, inputSequence, environment);\n            } else {\n                if(isTupleStream) {\n                    tupleBindings = await evaluateTupleStep(step, inputSequence, tupleBindings, environment);\n                } else {\n                    resultSequence = await evaluateStep(step, inputSequence, environment, ii === expr.steps.length - 1);\n                }\n            }\n\n            if (!isTupleStream && (typeof resultSequence === 'undefined' || resultSequence.length === 0)) {\n                break;\n            }\n\n            if(typeof step.focus === 'undefined') {\n                inputSequence = resultSequence;\n            }\n\n        }\n\n        if(isTupleStream) {\n            if(expr.tuple) {\n                // tuple stream is carrying ancestry information - keep this\n                resultSequence = tupleBindings;\n            } else {\n                resultSequence = createSequence();\n                for (ii = 0; ii < tupleBindings.length; ii++) {\n                    resultSequence.push(tupleBindings[ii]['@']);\n                }\n            }\n        }\n\n        if(expr.keepSingletonArray) {\n            // if the array is explicitly constructed in the expression and marked to promote singleton sequences to array\n            if(Array.isArray(resultSequence) && resultSequence.cons && !resultSequence.sequence) {\n                resultSequence = createSequence(resultSequence);\n            }\n            resultSequence.keepSingleton = true;\n        }\n\n        if (expr.hasOwnProperty('group')) {\n            resultSequence = await evaluateGroupExpression(expr.group, isTupleStream ? tupleBindings : resultSequence, environment)\n        }\n\n        return resultSequence;\n    }\n\n    function createFrameFromTuple(environment, tuple) {\n        var frame = createFrame(environment);\n        for(const prop in tuple) {\n            frame.bind(prop, tuple[prop]);\n        }\n        return frame;\n    }\n\n    /**\n     * Evaluate a step within a path\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @param {boolean} lastStep - flag the last step in a path\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateStep(expr, input, environment, lastStep) {\n        var result;\n        if(expr.type === 'sort') {\n             result = await evaluateSortExpression(expr, input, environment);\n             if(expr.stages) {\n                 result = await evaluateStages(expr.stages, result, environment);\n             }\n             return result;\n        }\n\n        result = createSequence();\n\n        for(var ii = 0; ii < input.length; ii++) {\n            var res = await evaluate(expr, input[ii], environment);\n            if(expr.stages) {\n                for(var ss = 0; ss < expr.stages.length; ss++) {\n                    res = await evaluateFilter(expr.stages[ss].expr, res, environment);\n                }\n            }\n            if(typeof res !== 'undefined') {\n                result.push(res);\n            }\n        }\n\n        var resultSequence = createSequence();\n        if(lastStep && result.length === 1 && Array.isArray(result[0]) && !isSequence(result[0])) {\n            resultSequence = result[0];\n        } else {\n            // flatten the sequence\n            result.forEach(function(res) {\n                if (!Array.isArray(res) || res.cons) {\n                    // it's not an array - just push into the result sequence\n                    resultSequence.push(res);\n                } else {\n                    // res is a sequence - flatten it into the parent sequence\n                    res.forEach(val => resultSequence.push(val));\n                }\n            });\n        }\n\n        return resultSequence;\n    }\n\n    async function evaluateStages(stages, input, environment) {\n        var result = input;\n        for(var ss = 0; ss < stages.length; ss++) {\n            var stage = stages[ss];\n            switch(stage.type) {\n                case 'filter':\n                    result = await evaluateFilter(stage.expr, result, environment);\n                    break;\n                case 'index':\n                    for(var ee = 0; ee < result.length; ee++) {\n                        var tuple = result[ee];\n                        tuple[stage.value] = ee;\n                    }\n                    break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate a step within a path\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} tupleBindings - The tuple stream\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateTupleStep(expr, input, tupleBindings, environment) {\n        var result;\n        if(expr.type === 'sort') {\n            if(tupleBindings) {\n                result = await evaluateSortExpression(expr, tupleBindings, environment);\n            } else {\n                var sorted = await evaluateSortExpression(expr, input, environment);\n                result = createSequence();\n                result.tupleStream = true;\n                for(var ss = 0; ss < sorted.length; ss++) {\n                    var tuple = {'@': sorted[ss]};\n                    tuple[expr.index] = ss;\n                    result.push(tuple);\n                }\n            }\n            if(expr.stages) {\n                result = await evaluateStages(expr.stages, result, environment);\n            }\n            return result;\n        }\n\n        result = createSequence();\n        result.tupleStream = true;\n        var stepEnv = environment;\n        if(tupleBindings === undefined) {\n            tupleBindings = input.map(item => { return {'@': item} });\n        }\n\n        for(var ee = 0; ee < tupleBindings.length; ee++) {\n            stepEnv = createFrameFromTuple(environment, tupleBindings[ee]);\n            var res = await evaluate(expr, tupleBindings[ee]['@'], stepEnv);\n            // res is the binding sequence for the output tuple stream\n            if(typeof res !== 'undefined') {\n                if (!Array.isArray(res)) {\n                    res = [res];\n                }\n                for (var bb = 0; bb < res.length; bb++) {\n                    tuple = {};\n                    Object.assign(tuple, tupleBindings[ee]);\n                    if(res.tupleStream) {\n                        Object.assign(tuple, res[bb]);\n                    } else {\n                        if (expr.focus) {\n                            tuple[expr.focus] = res[bb];\n                            tuple['@'] = tupleBindings[ee]['@'];\n                        } else {\n                            tuple['@'] = res[bb];\n                        }\n                        if (expr.index) {\n                            tuple[expr.index] = bb;\n                        }\n                        if (expr.ancestor) {\n                            tuple[expr.ancestor.label] = tupleBindings[ee]['@'];\n                        }\n                    }\n                    result.push(tuple);\n                }\n            }\n        }\n\n        if(expr.stages) {\n            result = await evaluateStages(expr.stages, result, environment);\n        }\n\n        return result;\n    }\n\n    /**\n     * Apply filter predicate to input data\n     * @param {Object} predicate - filter expression\n     * @param {Object} input - Input data to apply predicates against\n     * @param {Object} environment - Environment\n     * @returns {*} Result after applying predicates\n     */\n    async function evaluateFilter(predicate, input, environment) {\n        var results = createSequence();\n        if( input && input.tupleStream) {\n            results.tupleStream = true;\n        }\n        if (!Array.isArray(input)) {\n            input = createSequence(input);\n        }\n        if (predicate.type === 'number') {\n            var index = Math.floor(predicate.value);  // round it down\n            if (index < 0) {\n                // count in from end of array\n                index = input.length + index;\n            }\n            var item = input[index];\n            if(typeof item !== 'undefined') {\n                if(Array.isArray(item)) {\n                    results = item;\n                } else {\n                    results.push(item);\n                }\n            }\n        } else {\n            for (index = 0; index < input.length; index++) {\n                var item = input[index];\n                var context = item;\n                var env = environment;\n                if(input.tupleStream) {\n                    context = item['@'];\n                    env = createFrameFromTuple(environment, item);\n                }\n                var res = await evaluate(predicate, context, env);\n                if (isNumeric(res)) {\n                    res = [res];\n                }\n                if (isArrayOfNumbers(res)) {\n                    res.forEach(function (ires) {\n                        // round it down\n                        var ii = Math.floor(ires);\n                        if (ii < 0) {\n                            // count in from end of array\n                            ii = input.length + ii;\n                        }\n                        if (ii === index) {\n                            results.push(item);\n                        }\n                    });\n                } else if (fn.boolean(res)) { // truthy\n                    results.push(item);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Evaluate binary expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateBinary(expr, input, environment) {\n        var result;\n        var lhs = await evaluate(expr.lhs, input, environment);\n        var op = expr.value;\n\n        //defer evaluation of RHS to allow short-circuiting\n        var evalrhs = async () => await evaluate(expr.rhs, input, environment);\n        if (op === \"and\" || op === \"or\") {\n            try {\n                return await evaluateBooleanExpression(lhs, evalrhs, op);\n            } catch(err) {\n                err.position = expr.position;\n                err.token = op;\n                throw err;\n            }\n        }\n\n        var rhs = await evalrhs();\n        try {\n            switch (op) {\n                case '+':\n                case '-':\n                case '*':\n                case '/':\n                case '%':\n                    result = evaluateNumericExpression(lhs, rhs, op);\n                    break;\n                case '=':\n                case '!=':\n                    result = evaluateEqualityExpression(lhs, rhs, op);\n                    break;\n                case '<':\n                case '<=':\n                case '>':\n                case '>=':\n                    result = evaluateComparisonExpression(lhs, rhs, op);\n                    break;\n                case '&':\n                    result = evaluateStringConcat(lhs, rhs);\n                    break;\n                case '..':\n                    result = evaluateRangeExpression(lhs, rhs);\n                    break;\n                case 'in':\n                    result = evaluateIncludesExpression(lhs, rhs);\n                    break;\n            }\n        } catch(err) {\n            err.position = expr.position;\n            err.token = op;\n            throw err;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate unary expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateUnary(expr, input, environment) {\n        var result;\n\n        switch (expr.value) {\n            case '-':\n                result = await evaluate(expr.expression, input, environment);\n                if(typeof result === 'undefined') {\n                    result = undefined;\n                } else if (isNumeric(result)) {\n                    result = -result;\n                } else {\n                    throw {\n                        code: \"D1002\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        token: expr.value,\n                        value: result\n                    };\n                }\n                break;\n            case '[':\n                // array constructor - evaluate each item\n                result = [];\n                let generators = await Promise.all(expr.expressions\n                    .map(async (item, idx) => {\n                        environment.isParallelCall = idx > 0\n                        return [item, await evaluate(item, input, environment)]\n                    }));\n                for (let generator of generators) {\n                    var [item, value] = generator;\n                    if (typeof value !== 'undefined') {\n                        if(item.value === '[') {\n                            result.push(value);\n                        } else {\n                            result = fn.append(result, value);\n                        }\n                    }\n                }\n                if(expr.consarray) {\n                    Object.defineProperty(result, 'cons', {\n                        enumerable: false,\n                        configurable: false,\n                        value: true\n                    });\n                }\n                break;\n            case '{':\n                // object constructor - apply grouping\n                result = await evaluateGroupExpression(expr, input, environment);\n                break;\n\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate name object against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    function evaluateName(expr, input, environment) {\n        // lookup the 'name' item in the input\n        return fn.lookup(input, expr.value);\n    }\n\n    /**\n     * Evaluate literal against input data\n     * @param {Object} expr - JSONata expression\n     * @returns {*} Evaluated input data\n     */\n    function evaluateLiteral(expr) {\n        return expr.value;\n    }\n\n    /**\n     * Evaluate wildcard against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @returns {*} Evaluated input data\n     */\n    function evaluateWildcard(expr, input) {\n        var results = createSequence();\n        if (Array.isArray(input) && input.outerWrapper && input.length > 0) {\n            input = input[0];\n        }\n        if (input !== null && typeof input === 'object') {\n            Object.keys(input).forEach(function (key) {\n                var value = input[key];\n                if(Array.isArray(value)) {\n                    value = flatten(value);\n                    results = fn.append(results, value);\n                } else {\n                    results.push(value);\n                }\n            });\n        }\n\n        //        result = normalizeSequence(results);\n        return results;\n    }\n\n    /**\n     * Returns a flattened array\n     * @param {Array} arg - the array to be flatten\n     * @param {Array} flattened - carries the flattened array - if not defined, will initialize to []\n     * @returns {Array} - the flattened array\n     */\n    function flatten(arg, flattened) {\n        if(typeof flattened === 'undefined') {\n            flattened = [];\n        }\n        if(Array.isArray(arg)) {\n            arg.forEach(function (item) {\n                flatten(item, flattened);\n            });\n        } else {\n            flattened.push(arg);\n        }\n        return flattened;\n    }\n\n    /**\n     * Evaluate descendants against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @returns {*} Evaluated input data\n     */\n    function evaluateDescendants(expr, input) {\n        var result;\n        var resultSequence = createSequence();\n        if (typeof input !== 'undefined') {\n            // traverse all descendants of this object/array\n            recurseDescendants(input, resultSequence);\n            if (resultSequence.length === 1) {\n                result = resultSequence[0];\n            } else {\n                result = resultSequence;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Recurse through descendants\n     * @param {Object} input - Input data\n     * @param {Object} results - Results\n     */\n    function recurseDescendants(input, results) {\n        // this is the equivalent of //* in XPath\n        if (!Array.isArray(input)) {\n            results.push(input);\n        }\n        if (Array.isArray(input)) {\n            input.forEach(function (member) {\n                recurseDescendants(member, results);\n            });\n        } else if (input !== null && typeof input === 'object') {\n            Object.keys(input).forEach(function (key) {\n                recurseDescendants(input[key], results);\n            });\n        }\n    }\n\n    /**\n     * Evaluate numeric expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    function evaluateNumericExpression(lhs, rhs, op) {\n        var result;\n\n        if (typeof lhs !== 'undefined' && !isNumeric(lhs)) {\n            throw {\n                code: \"T2001\",\n                stack: (new Error()).stack,\n                value: lhs\n            };\n        }\n        if (typeof rhs !== 'undefined' && !isNumeric(rhs)) {\n            throw {\n                code: \"T2002\",\n                stack: (new Error()).stack,\n                value: rhs\n            };\n        }\n\n        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {\n            // if either side is undefined, the result is undefined\n            return result;\n        }\n\n        switch (op) {\n            case '+':\n                result = lhs + rhs;\n                break;\n            case '-':\n                result = lhs - rhs;\n                break;\n            case '*':\n                result = lhs * rhs;\n                break;\n            case '/':\n                result = lhs / rhs;\n                break;\n            case '%':\n                result = lhs % rhs;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate equality expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    function evaluateEqualityExpression(lhs, rhs, op) {\n        var result;\n\n        // type checks\n        var ltype = typeof lhs;\n        var rtype = typeof rhs;\n\n        if (ltype === 'undefined' || rtype === 'undefined') {\n            // if either side is undefined, the result is false\n            return false;\n        }\n\n        switch (op) {\n            case '=':\n                result = isDeepEqual(lhs, rhs);\n                break;\n            case '!=':\n                result = !isDeepEqual(lhs, rhs);\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate comparison expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    function evaluateComparisonExpression(lhs, rhs, op) {\n        var result;\n\n        // type checks\n        var ltype = typeof lhs;\n        var rtype = typeof rhs;\n\n        var lcomparable = (ltype === 'undefined' || ltype === 'string' || ltype === 'number');\n        var rcomparable = (rtype === 'undefined' || rtype === 'string' || rtype === 'number');\n\n        // if either aa or bb are not comparable (string or numeric) values, then throw an error\n        if (!lcomparable || !rcomparable) {\n            throw {\n                code: \"T2010\",\n                stack: (new Error()).stack,\n                value: !(ltype === 'string' || ltype === 'number') ? lhs : rhs\n            };\n        }\n\n        // if either side is undefined, the result is undefined\n        if (ltype === 'undefined' || rtype === 'undefined') {\n            return undefined;\n        }\n\n        //if aa and bb are not of the same type\n        if (ltype !== rtype) {\n            throw {\n                code: \"T2009\",\n                stack: (new Error()).stack,\n                value: lhs,\n                value2: rhs\n            };\n        }\n\n        switch (op) {\n            case '<':\n                result = lhs < rhs;\n                break;\n            case '<=':\n                result = lhs <= rhs;\n                break;\n            case '>':\n                result = lhs > rhs;\n                break;\n            case '>=':\n                result = lhs >= rhs;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Inclusion operator - in\n     *\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @returns {boolean} - true if lhs is a member of rhs\n     */\n    function evaluateIncludesExpression(lhs, rhs) {\n        var result = false;\n\n        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {\n            // if either side is undefined, the result is false\n            return false;\n        }\n\n        if(!Array.isArray(rhs)) {\n            rhs = [rhs];\n        }\n\n        for(var i = 0; i < rhs.length; i++) {\n            if(rhs[i] === lhs) {\n                result = true;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate boolean expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Function} evalrhs - function to evaluate RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    async function evaluateBooleanExpression(lhs, evalrhs, op) {\n        var result;\n\n        var lBool = boolize(lhs);\n\n        switch (op) {\n            case 'and':\n                result = lBool && boolize(await evalrhs());\n                break;\n            case 'or':\n                result = lBool || boolize(await evalrhs());\n                break;\n        }\n        return result;\n    }\n\n    function boolize(value) {\n        var booledValue = fn.boolean(value);\n        return typeof booledValue === 'undefined' ? false : booledValue;\n    }\n\n    /**\n     * Evaluate string concatenation against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @returns {string|*} Concatenated string\n     */\n    function evaluateStringConcat(lhs, rhs) {\n        var result;\n\n        var lstr = '';\n        var rstr = '';\n        if (typeof lhs !== 'undefined') {\n            lstr = fn.string(lhs);\n        }\n        if (typeof rhs !== 'undefined') {\n            rstr = fn.string(rhs);\n        }\n\n        result = lstr.concat(rstr);\n        return result;\n    }\n\n    /**\n     * Evaluate group expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {{}} Evaluated input data\n     */\n    async function evaluateGroupExpression(expr, input, environment) {\n        var result = {};\n        var groups = {};\n        var reduce = input && input.tupleStream ? true : false;\n        // group the input sequence by 'key' expression\n        if (!Array.isArray(input)) {\n            input = createSequence(input);\n        }\n        // if the array is empty, add an undefined entry to enable literal JSON object to be generated\n        if (input.length === 0) {\n            input.push(undefined);\n        }\n\n        for(var itemIndex = 0; itemIndex < input.length; itemIndex++) {\n            var item = input[itemIndex];\n            var env = reduce ? createFrameFromTuple(environment, item) : environment;\n            for(var pairIndex = 0; pairIndex < expr.lhs.length; pairIndex++) {\n                var pair = expr.lhs[pairIndex];\n                var key = await evaluate(pair[0], reduce ? item['@'] : item, env);\n                // key has to be a string\n                if (typeof  key !== 'string' && key !== undefined) {\n                    throw {\n                        code: \"T1003\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        value: key\n                    };\n                }\n\n                if (key !== undefined) {\n                    var entry = {data: item, exprIndex: pairIndex};\n                    if (groups.hasOwnProperty(key)) {\n                        // a value already exists in this slot\n                        if(groups[key].exprIndex !== pairIndex) {\n                            // this key has been generated by another expression in this group\n                            // when multiple key expressions evaluate to the same key, then error D1009 must be thrown\n                            throw {\n                                code: \"D1009\",\n                                stack: (new Error()).stack,\n                                position: expr.position,\n                                value: key\n                            };\n                        }\n\n                        // append it as an array\n                        groups[key].data = fn.append(groups[key].data, item);\n                    } else {\n                        groups[key] = entry;\n                    }\n                }\n            }\n        }\n\n        // iterate over the groups to evaluate the 'value' expression\n        let generators = await Promise.all(Object.keys(groups).map(async (key, idx) => {\n            let entry = groups[key];\n            var context = entry.data;\n            var env = environment;\n            if (reduce) {\n                var tuple = reduceTupleStream(entry.data);\n                context = tuple['@'];\n                delete tuple['@'];\n                env = createFrameFromTuple(environment, tuple);\n            }\n            environment.isParallelCall = idx > 0\n            return [key, await evaluate(expr.lhs[entry.exprIndex][1], context, env)];\n        }));\n\n        for (let generator of generators) {\n            var [key, value] = await generator;\n            if(typeof value !== 'undefined') {\n                result[key] = value;\n            }\n        }\n\n        return result;\n    }\n\n    function reduceTupleStream(tupleStream) {\n        if(!Array.isArray(tupleStream)) {\n            return tupleStream;\n        }\n        var result = {};\n        Object.assign(result, tupleStream[0]);\n        for(var ii = 1; ii < tupleStream.length; ii++) {\n            for(const prop in tupleStream[ii]) {\n                result[prop] = fn.append(result[prop], tupleStream[ii][prop]);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate range expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @returns {Array} Resultant array\n     */\n    function evaluateRangeExpression(lhs, rhs) {\n        var result;\n\n        if (typeof lhs !== 'undefined' && !Number.isInteger(lhs)) {\n            throw {\n                code: \"T2003\",\n                stack: (new Error()).stack,\n                value: lhs\n            };\n        }\n        if (typeof rhs !== 'undefined' && !Number.isInteger(rhs)) {\n            throw {\n                code: \"T2004\",\n                stack: (new Error()).stack,\n                value: rhs\n            };\n        }\n\n        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {\n            // if either side is undefined, the result is undefined\n            return result;\n        }\n\n        if (lhs > rhs) {\n            // if the lhs is greater than the rhs, return undefined\n            return result;\n        }\n\n        // limit the size of the array to ten million entries (1e7)\n        // this is an implementation defined limit to protect against\n        // memory and performance issues.  This value may increase in the future.\n        var size = rhs - lhs + 1;\n        if(size > 1e7) {\n            throw {\n                code: \"D2014\",\n                stack: (new Error()).stack,\n                value: size\n            };\n        }\n\n        result = new Array(size);\n        for (var item = lhs, index = 0; item <= rhs; item++, index++) {\n            result[index] = item;\n        }\n        result.sequence = true;\n        return result;\n    }\n\n    /**\n     * Evaluate bind expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateBindExpression(expr, input, environment) {\n        // The RHS is the expression to evaluate\n        // The LHS is the name of the variable to bind to - should be a VARIABLE token (enforced by parser)\n        var value = await evaluate(expr.rhs, input, environment);\n        environment.bind(expr.lhs.value, value);\n        return value;\n    }\n\n    /**\n     * Evaluate condition against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateCondition(expr, input, environment) {\n        var result;\n        var condition = await evaluate(expr.condition, input, environment);\n        if (fn.boolean(condition)) {\n            result = await evaluate(expr.then, input, environment);\n        } else if (typeof expr.else !== 'undefined') {\n            result = await evaluate(expr.else, input, environment);\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate block against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateBlock(expr, input, environment) {\n        var result;\n        // create a new frame to limit the scope of variable assignments\n        // TODO, only do this if the post-parse stage has flagged this as required\n        var frame = createFrame(environment);\n        // invoke each expression in turn\n        // only return the result of the last one\n        for(var ii = 0; ii < expr.expressions.length; ii++) {\n            result = await evaluate(expr.expressions[ii], input, frame);\n        }\n\n        return result;\n    }\n\n    /**\n     * Prepare a regex\n     * @param {Object} expr - expression containing regex\n     * @returns {Function} Higher order function representing prepared regex\n     */\n    function evaluateRegex(expr) {\n        var re = new jsonata.RegexEngine(expr.value);\n        var closure = function(str, fromIndex) {\n            var result;\n            re.lastIndex = fromIndex || 0;\n            var match = re.exec(str);\n            if(match !== null) {\n                result = {\n                    match: match[0],\n                    start: match.index,\n                    end: match.index + match[0].length,\n                    groups: []\n                };\n                if(match.length > 1) {\n                    for(var i = 1; i < match.length; i++) {\n                        result.groups.push(match[i]);\n                    }\n                }\n                result.next = function() {\n                    if(re.lastIndex >= str.length) {\n                        return undefined;\n                    } else {\n                        var next = closure(str, re.lastIndex);\n                        if(next && next.match === '') {\n                            // matches zero length string; this will never progress\n                            throw {\n                                code: \"D1004\",\n                                stack: (new Error()).stack,\n                                position: expr.position,\n                                value: expr.value.source\n                            };\n                        }\n                        return next;\n                    }\n                };\n            }\n\n            return result;\n        };\n        return closure;\n    }\n\n    /**\n     * Evaluate variable against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    function evaluateVariable(expr, input, environment) {\n        // lookup the variable value in the environment\n        var result;\n        // if the variable name is empty string, then it refers to context value\n        if (expr.value === '') {\n            result = input && input.outerWrapper ? input[0] : input;\n        } else {\n            result = environment.lookup(expr.value);\n        }\n        return result;\n    }\n\n    /**\n     * sort / order-by operator\n     * @param {Object} expr - AST for operator\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Ordered sequence\n     */\n    async function evaluateSortExpression(expr, input, environment) {\n        var result;\n\n        // evaluate the lhs, then sort the results in order according to rhs expression\n        var lhs = input;\n        var isTupleSort = input.tupleStream ? true : false;\n\n        // sort the lhs array\n        // use comparator function\n        var comparator = async function(a, b) { \n            // expr.terms is an array of order-by in priority order\n            var comp = 0;\n            for(var index = 0; comp === 0 && index < expr.terms.length; index++) {\n                var term = expr.terms[index];\n                //evaluate the sort term in the context of a\n                var context = a;\n                var env = environment;\n                if(isTupleSort) {\n                    context = a['@'];\n                    env = createFrameFromTuple(environment, a);\n                }\n                var aa = await evaluate(term.expression, context, env);\n                //evaluate the sort term in the context of b\n                context = b;\n                env = environment;\n                if(isTupleSort) {\n                    context = b['@'];\n                    env = createFrameFromTuple(environment, b);\n                }\n                var bb = await evaluate(term.expression, context, env);\n\n                // type checks\n                var atype = typeof aa;\n                var btype = typeof bb;\n                // undefined should be last in sort order\n                if(atype === 'undefined') {\n                    // swap them, unless btype is also undefined\n                    comp = (btype === 'undefined') ? 0 : 1;\n                    continue;\n                }\n                if(btype === 'undefined') {\n                    comp = -1;\n                    continue;\n                }\n\n                // if aa or bb are not string or numeric values, then throw an error\n                if(!(atype === 'string' || atype === 'number') || !(btype === 'string' || btype === 'number')) {\n                    throw {\n                        code: \"T2008\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        value: !(atype === 'string' || atype === 'number') ? aa : bb\n                    };\n                }\n\n                //if aa and bb are not of the same type\n                if(atype !== btype) {\n                    throw {\n                        code: \"T2007\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        value: aa,\n                        value2: bb\n                    };\n                }\n                if(aa === bb) {\n                    // both the same - move on to next term\n                    continue;\n                } else if (aa < bb) {\n                    comp = -1;\n                } else {\n                    comp = 1;\n                }\n                if(term.descending === true) {\n                    comp = -comp;\n                }\n            }\n            // only swap a & b if comp equals 1\n            return comp === 1;\n        };\n\n        var focus = {\n            environment: environment,\n            input: input\n        };\n        // the `focus` is passed in as the `this` for the invoked function\n        result = await fn.sort.apply(focus, [lhs, comparator]);\n\n        return result;\n    }\n\n    /**\n     * create a transformer function\n     * @param {Object} expr - AST for operator\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} tranformer function\n     */\n    function evaluateTransformExpression(expr, input, environment) {\n        // create a function to implement the transform definition\n        var transformer = async function (obj) { // signature <(oa):o>\n            // undefined inputs always return undefined\n            if(typeof obj === 'undefined') {\n                return undefined;\n            }\n\n            // this function returns a copy of obj with changes specified by the pattern/operation\n            var cloneFunction = environment.lookup('clone');\n            if(!isFunction(cloneFunction)) {\n                // throw type error\n                throw {\n                    code: \"T2013\",\n                    stack: (new Error()).stack,\n                    position: expr.position\n                };\n            }\n            var result = await apply(cloneFunction, [obj], null, environment);\n            var matches = await evaluate(expr.pattern, result, environment);\n            if(typeof matches !== 'undefined') {\n                if(!Array.isArray(matches)) {\n                    matches = [matches];\n                }\n                for(var ii = 0; ii < matches.length; ii++) {\n                    var match = matches[ii];\n                    if (match && (match.isPrototypeOf(result) || match instanceof Object.constructor)) {\n                        throw {\n                            code: \"D1010\",\n                            stack: (new Error()).stack,\n                            position: expr.position\n                        };\n                    }\n                    // evaluate the update value for each match\n                    var update = await evaluate(expr.update, match, environment);\n                    // update must be an object\n                    var updateType = typeof update;\n                    if(updateType !== 'undefined') {\n                        if(updateType !== 'object' || update === null || Array.isArray(update)) {\n                            // throw type error\n                            throw {\n                                code: \"T2011\",\n                                stack: (new Error()).stack,\n                                position: expr.update.position,\n                                value: update\n                            };\n                        }\n                        // merge the update\n                        for(var prop in update) {\n                            match[prop] = update[prop];\n                        }\n                    }\n\n                    // delete, if specified, must be an array of strings (or single string)\n                    if(typeof expr.delete !== 'undefined') {\n                        var deletions = await evaluate(expr.delete, match, environment);\n                        if(typeof deletions !== 'undefined') {\n                            var val = deletions;\n                            if (!Array.isArray(deletions)) {\n                                deletions = [deletions];\n                            }\n                            if (!isArrayOfStrings(deletions)) {\n                                // throw type error\n                                throw {\n                                    code: \"T2012\",\n                                    stack: (new Error()).stack,\n                                    position: expr.delete.position,\n                                    value: val\n                                };\n                            }\n                            for (var jj = 0; jj < deletions.length; jj++) {\n                                if(typeof match === 'object' && match !== null) {\n                                    delete match[deletions[jj]];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        return defineFunction(transformer, '<(oa):o>');\n    }\n\n    var chainAST = parser('function($f, $g) { function($x){ $g($f($x)) } }');\n\n    /**\n     * Apply the function on the RHS using the sequence on the LHS as the first argument\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateApplyExpression(expr, input, environment) {\n        var result;\n\n\n        var lhs = await evaluate(expr.lhs, input, environment);\n        if(expr.rhs.type === 'function') {\n            // this is a function _invocation_; invoke it with lhs expression as the first argument\n            result = await evaluateFunction(expr.rhs, input, environment, { context: lhs });\n        } else {\n            var func = await evaluate(expr.rhs, input, environment);\n\n            if(!isFunction(func)) {\n                throw {\n                    code: \"T2006\",\n                    stack: (new Error()).stack,\n                    position: expr.position,\n                    value: func\n                };\n            }\n\n            if(isFunction(lhs)) {\n                // this is function chaining (func1 ~> func2)\n                // ($f, $g) { ($x){ $g($f($x)) } }\n                var chain = await evaluate(chainAST, null, environment);\n                result = await apply(chain, [lhs, func], null, environment);\n            } else {\n                result = await apply(func, [lhs], null, environment);\n            }\n\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate function against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateFunction(expr, input, environment, applyto) {\n        var result;\n\n        // create the procedure\n        // can't assume that expr.procedure is a lambda type directly\n        // could be an expression that evaluates to a function (e.g. variable reference, parens expr etc.\n        // evaluate it generically first, then check that it is a function.  Throw error if not.\n        var proc = await evaluate(expr.procedure, input, environment);\n\n        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {\n            // help the user out here if they simply forgot the leading $\n            throw {\n                code: \"T1005\",\n                stack: (new Error()).stack,\n                position: expr.position,\n                token: expr.procedure.steps[0].value\n            };\n        }\n\n        var evaluatedArgs = [];\n        if(typeof applyto !== 'undefined') {\n            evaluatedArgs.push(applyto.context);\n        }\n        // eager evaluation - evaluate the arguments\n        for (var jj = 0; jj < expr.arguments.length; jj++) {\n            const arg = await evaluate(expr.arguments[jj], input, environment);\n            if(isFunction(arg)) {\n                // wrap this in a closure\n                const closure = async function (...params) {\n                    // invoke func\n                    return await apply(arg, params, null, environment);\n                };\n                closure.arity = getFunctionArity(arg);\n                evaluatedArgs.push(closure);\n            } else {\n                evaluatedArgs.push(arg);\n            }\n        }\n        // apply the procedure\n        var procName = expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value;\n        try {\n            if(typeof proc === 'object') {\n                proc.token = procName;\n                proc.position = expr.position;\n            }\n            result = await apply(proc, evaluatedArgs, input, environment);\n        } catch (err) {\n            if(!err.position) {\n                // add the position field to the error\n                err.position = expr.position;\n            }\n            if (!err.token) {\n                // and the function identifier\n                err.token = procName;\n            }\n            throw err;\n        }\n        return result;\n    }\n\n    /**\n     * Apply procedure or function\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @param {Object} input - input\n     * @param {Object} environment - environment\n     * @returns {*} Result of procedure\n     */\n    async function apply(proc, args, input, environment) {\n        var result;\n        result = await applyInner(proc, args, input, environment);\n        while(isLambda(result) && result.thunk === true) {\n            // trampoline loop - this gets invoked as a result of tail-call optimization\n            // the function returned a tail-call thunk\n            // unpack it, evaluate its arguments, and apply the tail call\n            var next = await evaluate(result.body.procedure, result.input, result.environment);\n            if(result.body.procedure.type === 'variable') {\n                next.token = result.body.procedure.value;\n            }\n            next.position = result.body.procedure.position;\n            var evaluatedArgs = [];\n            for(var ii = 0; ii < result.body.arguments.length; ii++) {\n                evaluatedArgs.push(await evaluate(result.body.arguments[ii], result.input, result.environment));\n            }\n\n            result = await applyInner(next, evaluatedArgs, input, environment);\n        }\n        return result;\n    }\n\n    /**\n     * Apply procedure or function\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @param {Object} input - input\n     * @param {Object} environment - environment\n     * @returns {*} Result of procedure\n     */\n    async function applyInner(proc, args, input, environment) {\n        var result;\n        try {\n            var validatedArgs = args;\n            if (proc) {\n                validatedArgs = validateArguments(proc.signature, args, input);\n            }\n\n            if (isLambda(proc)) {\n                result = await applyProcedure(proc, validatedArgs);\n            } else if (proc && proc._jsonata_function === true) {\n                var focus = {\n                    environment: environment,\n                    input: input\n                };\n                // the `focus` is passed in as the `this` for the invoked function\n                result = proc.implementation.apply(focus, validatedArgs);\n                // `proc.implementation` might be a generator function\n                // and `result` might be a generator - if so, yield\n                if (isIterable(result)) {\n                    result = result.next().value;\n                }\n                if (isPromise(result)) {\n                    result = await result;\n                }\n            } else if (typeof proc === 'function') {\n                // typically these are functions that are returned by the invocation of plugin functions\n                // the `input` is being passed in as the `this` for the invoked function\n                // this is so that functions that return objects containing functions can chain\n                // e.g. await (await $func())\n                result = proc.apply(input, validatedArgs);\n                if (isPromise(result)) {\n                    result = await result;\n                }\n            } else {\n                throw {\n                    code: \"T1006\",\n                    stack: (new Error()).stack\n                };\n            }\n        } catch(err) {\n            if(proc) {\n                if (typeof err.token == 'undefined' && typeof proc.token !== 'undefined') {\n                    err.token = proc.token;\n                }\n                err.position = proc.position || err.position;\n            }\n            throw err;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate lambda against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {{lambda: boolean, input: *, environment: *, arguments: *, body: *}} Evaluated input data\n     */\n    function evaluateLambda(expr, input, environment) {\n        // make a function (closure)\n        var procedure = {\n            _jsonata_lambda: true,\n            input: input,\n            environment: environment,\n            arguments: expr.arguments,\n            signature: expr.signature,\n            body: expr.body\n        };\n        if(expr.thunk === true) {\n            procedure.thunk = true;\n        }\n        procedure.apply = async function(self, args) {\n            return await apply(procedure, args, input, !!self ? self.environment : environment);\n        };\n        return procedure;\n    }\n\n    /**\n     * Evaluate partial application\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluatePartialApplication(expr, input, environment) {\n        // partially apply a function\n        var result;\n        // evaluate the arguments\n        var evaluatedArgs = [];\n        for(var ii = 0; ii < expr.arguments.length; ii++) {\n            var arg = expr.arguments[ii];\n            if (arg.type === 'operator' && arg.value === '?') {\n                evaluatedArgs.push(arg);\n            } else {\n                evaluatedArgs.push(await evaluate(arg, input, environment));\n            }\n        }\n        // lookup the procedure\n        var proc = await evaluate(expr.procedure, input, environment);\n        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {\n            // help the user out here if they simply forgot the leading $\n            throw {\n                code: \"T1007\",\n                stack: (new Error()).stack,\n                position: expr.position,\n                token: expr.procedure.steps[0].value\n            };\n        }\n        if (isLambda(proc)) {\n            result = partialApplyProcedure(proc, evaluatedArgs);\n        } else if (proc && proc._jsonata_function === true) {\n            result = partialApplyNativeFunction(proc.implementation, evaluatedArgs);\n        } else if (typeof proc === 'function') {\n            result = partialApplyNativeFunction(proc, evaluatedArgs);\n        } else {\n            throw {\n                code: \"T1008\",\n                stack: (new Error()).stack,\n                position: expr.position,\n                token: expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Validate the arguments against the signature validator (if it exists)\n     * @param {Function} signature - validator function\n     * @param {Array} args - function arguments\n     * @param {*} context - context value\n     * @returns {Array} - validated arguments\n     */\n    function validateArguments(signature, args, context) {\n        if(typeof signature === 'undefined') {\n            // nothing to validate\n            return args;\n        }\n        var validatedArgs = signature.validate(args, context);\n        return validatedArgs;\n    }\n\n    /**\n     * Apply procedure\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @returns {*} Result of procedure\n     */\n    async function applyProcedure(proc, args) {\n        var result;\n        var env = createFrame(proc.environment);\n        proc.arguments.forEach(function (param, index) {\n            env.bind(param.value, args[index]);\n        });\n        if (typeof proc.body === 'function') {\n            // this is a lambda that wraps a native function - generated by partially evaluating a native\n            result = await applyNativeFunction(proc.body, env);\n        } else {\n            result = await evaluate(proc.body, proc.input, env);\n        }\n        return result;\n    }\n\n    /**\n     * Partially apply procedure\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applied procedure\n     */\n    function partialApplyProcedure(proc, args) {\n        // create a closure, bind the supplied parameters and return a function that takes the remaining (?) parameters\n        var env = createFrame(proc.environment);\n        var unboundArgs = [];\n        proc.arguments.forEach(function (param, index) {\n            var arg = args[index];\n            if (arg && arg.type === 'operator' && arg.value === '?') {\n                unboundArgs.push(param);\n            } else {\n                env.bind(param.value, arg);\n            }\n        });\n        var procedure = {\n            _jsonata_lambda: true,\n            input: proc.input,\n            environment: env,\n            arguments: unboundArgs,\n            body: proc.body\n        };\n        return procedure;\n    }\n\n    /**\n     * Partially apply native function\n     * @param {Function} native - Native function\n     * @param {Array} args - Arguments\n     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applying native function\n     */\n    function partialApplyNativeFunction(native, args) {\n        // create a lambda function that wraps and invokes the native function\n        // get the list of declared arguments from the native function\n        // this has to be picked out from the toString() value\n        var sigArgs = getNativeFunctionArguments(native);\n        sigArgs = sigArgs.map(function (sigArg) {\n            return '$' + sigArg.trim();\n        });\n        var body = 'function(' + sigArgs.join(', ') + '){ _ }';\n\n        var bodyAST = parser(body);\n        bodyAST.body = native;\n\n        var partial = partialApplyProcedure(bodyAST, args);\n        return partial;\n    }\n\n    /**\n     * Apply native function\n     * @param {Object} proc - Procedure\n     * @param {Object} env - Environment\n     * @returns {*} Result of applying native function\n     */\n    async function applyNativeFunction(proc, env) {\n        var sigArgs = getNativeFunctionArguments(proc);\n        // generate the array of arguments for invoking the function - look them up in the environment\n        var args = sigArgs.map(function (sigArg) {\n            return env.lookup(sigArg.trim());\n        });\n\n        var focus = {\n            environment: env\n        };\n        var result = proc.apply(focus, args);\n        if (isPromise(result)) {\n            result = await result;\n        }\n        return result;\n    }\n\n    /**\n     * Get native function arguments\n     * @param {Function} func - Function\n     * @returns {*|Array} Native function arguments\n     */\n    function getNativeFunctionArguments(func) {\n        var signature = func.toString();\n        var sigParens = /\\(([^)]*)\\)/.exec(signature)[1]; // the contents of the parens\n        var sigArgs = sigParens.split(',');\n        return sigArgs;\n    }\n\n    /**\n     * Creates a function definition\n     * @param {Function} func - function implementation in Javascript\n     * @param {string} signature - JSONata function signature definition\n     * @returns {{implementation: *, signature: *}} function definition\n     */\n    function defineFunction(func, signature) {\n        var definition = {\n            _jsonata_function: true,\n            implementation: func\n        };\n        if(typeof signature !== 'undefined') {\n            definition.signature = parseSignature(signature);\n        }\n        return definition;\n    }\n\n\n    /**\n     * parses and evaluates the supplied expression\n     * @param {string} expr - expression to evaluate\n     * @returns {*} - result of evaluating the expression\n     */\n    async function functionEval(expr, focus) {\n        // undefined inputs always return undefined\n        if(typeof expr === 'undefined') {\n            return undefined;\n        }\n        var input = this.input;\n        if(typeof focus !== 'undefined') {\n            input = focus;\n            // if the input is a JSON array, then wrap it in a singleton sequence so it gets treated as a single input\n            if(Array.isArray(input) && !isSequence(input)) {\n                input = createSequence(input);\n                input.outerWrapper = true;\n            }\n        }\n\n        try {\n            var ast = parser(expr, false);\n        } catch(err) {\n            // error parsing the expression passed to $eval\n            populateMessage(err);\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3120\",\n                value: err.message,\n                error: err\n            };\n        }\n        try {\n            var result = await evaluate(ast, input, this.environment);\n        } catch(err) {\n            // error evaluating the expression passed to $eval\n            populateMessage(err);\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3121\",\n                value:err.message,\n                error: err\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     * Clones an object\n     * @param {Object} arg - object to clone (deep copy)\n     * @returns {*} - the cloned object\n     */\n    function functionClone(arg) {\n        // undefined inputs always return undefined\n        if(typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        return JSON.parse(fn.string(arg));\n    }\n\n    /**\n     * Create frame\n     * @param {Object} enclosingEnvironment - Enclosing environment\n     * @returns {{bind: bind, lookup: lookup}} Created frame\n     */\n    function createFrame(enclosingEnvironment) {\n        var bindings = {};\n        const newFrame = {\n            bind: function (name, value) {\n                bindings[name] = value;\n            },\n            lookup: function (name) {\n                var value;\n                if(bindings.hasOwnProperty(name)) {\n                    value = bindings[name];\n                } else if (enclosingEnvironment) {\n                    value = enclosingEnvironment.lookup(name);\n                }\n                return value;\n            },\n            timestamp: enclosingEnvironment ? enclosingEnvironment.timestamp : null,\n            async: enclosingEnvironment ? enclosingEnvironment.async : false,\n            isParallelCall: enclosingEnvironment ? enclosingEnvironment.isParallelCall : false,\n            global: enclosingEnvironment ? enclosingEnvironment.global : {\n                ancestry: [ null ]\n            }\n        };\n\n        if (enclosingEnvironment) {\n            var framePushCallback = enclosingEnvironment.lookup(Symbol.for('jsonata.__createFrame_push'));\n            if(framePushCallback) {\n                framePushCallback(enclosingEnvironment, newFrame);\n            }\n        }\n       \n\n        return newFrame\n    }\n\n    // Function registration\n    staticFrame.bind('sum', defineFunction(fn.sum, '<a<n>:n>'));\n    staticFrame.bind('count', defineFunction(fn.count, '<a:n>'));\n    staticFrame.bind('max', defineFunction(fn.max, '<a<n>:n>'));\n    staticFrame.bind('min', defineFunction(fn.min, '<a<n>:n>'));\n    staticFrame.bind('average', defineFunction(fn.average, '<a<n>:n>'));\n    staticFrame.bind('string', defineFunction(fn.string, '<x-b?:s>'));\n    staticFrame.bind('substring', defineFunction(fn.substring, '<s-nn?:s>'));\n    staticFrame.bind('substringBefore', defineFunction(fn.substringBefore, '<s-s:s>'));\n    staticFrame.bind('substringAfter', defineFunction(fn.substringAfter, '<s-s:s>'));\n    staticFrame.bind('lowercase', defineFunction(fn.lowercase, '<s-:s>'));\n    staticFrame.bind('uppercase', defineFunction(fn.uppercase, '<s-:s>'));\n    staticFrame.bind('length', defineFunction(fn.length, '<s-:n>'));\n    staticFrame.bind('trim', defineFunction(fn.trim, '<s-:s>'));\n    staticFrame.bind('pad', defineFunction(fn.pad, '<s-ns?:s>'));\n    staticFrame.bind('match', defineFunction(fn.match, '<s-f<s:o>n?:a<o>>'));\n    staticFrame.bind('contains', defineFunction(fn.contains, '<s-(sf):b>')); // TODO <s-(sf<s:o>):b>\n    staticFrame.bind('replace', defineFunction(fn.replace, '<s-(sf)(sf)n?:s>')); // TODO <s-(sf<s:o>)(sf<o:s>)n?:s>\n    staticFrame.bind('split', defineFunction(fn.split, '<s-(sf)n?:a<s>>')); // TODO <s-(sf<s:o>)n?:a<s>>\n    staticFrame.bind('join', defineFunction(fn.join, '<a<s>s?:s>'));\n    staticFrame.bind('formatNumber', defineFunction(fn.formatNumber, '<n-so?:s>'));\n    staticFrame.bind('formatBase', defineFunction(fn.formatBase, '<n-n?:s>'));\n    staticFrame.bind('formatInteger', defineFunction(datetime.formatInteger, '<n-s:s>'));\n    staticFrame.bind('parseInteger', defineFunction(datetime.parseInteger, '<s-s:n>'));\n    staticFrame.bind('number', defineFunction(fn.number, '<(nsb)-:n>'));\n    staticFrame.bind('floor', defineFunction(fn.floor, '<n-:n>'));\n    staticFrame.bind('ceil', defineFunction(fn.ceil, '<n-:n>'));\n    staticFrame.bind('round', defineFunction(fn.round, '<n-n?:n>'));\n    staticFrame.bind('abs', defineFunction(fn.abs, '<n-:n>'));\n    staticFrame.bind('sqrt', defineFunction(fn.sqrt, '<n-:n>'));\n    staticFrame.bind('power', defineFunction(fn.power, '<n-n:n>'));\n    staticFrame.bind('random', defineFunction(fn.random, '<:n>'));\n    staticFrame.bind('boolean', defineFunction(fn.boolean, '<x-:b>'));\n    staticFrame.bind('not', defineFunction(fn.not, '<x-:b>'));\n    staticFrame.bind('map', defineFunction(fn.map, '<af>'));\n    staticFrame.bind('zip', defineFunction(fn.zip, '<a+>'));\n    staticFrame.bind('filter', defineFunction(fn.filter, '<af>'));\n    staticFrame.bind('single', defineFunction(fn.single, '<af?>'));\n    staticFrame.bind('reduce', defineFunction(fn.foldLeft, '<afj?:j>')); // TODO <f<jj:j>a<j>j?:j>\n    staticFrame.bind('sift', defineFunction(fn.sift, '<o-f?:o>'));\n    staticFrame.bind('keys', defineFunction(fn.keys, '<x-:a<s>>'));\n    staticFrame.bind('lookup', defineFunction(fn.lookup, '<x-s:x>'));\n    staticFrame.bind('append', defineFunction(fn.append, '<xx:a>'));\n    staticFrame.bind('exists', defineFunction(fn.exists, '<x:b>'));\n    staticFrame.bind('spread', defineFunction(fn.spread, '<x-:a<o>>'));\n    staticFrame.bind('merge', defineFunction(fn.merge, '<a<o>:o>'));\n    staticFrame.bind('reverse', defineFunction(fn.reverse, '<a:a>'));\n    staticFrame.bind('each', defineFunction(fn.each, '<o-f:a>'));\n    staticFrame.bind('error', defineFunction(fn.error, '<s?:x>'));\n    staticFrame.bind('assert', defineFunction(fn.assert, '<bs?:x>'));\n    staticFrame.bind('type', defineFunction(fn.type, '<x:s>'));\n    staticFrame.bind('sort', defineFunction(fn.sort, '<af?:a>'));\n    staticFrame.bind('shuffle', defineFunction(fn.shuffle, '<a:a>'));\n    staticFrame.bind('distinct', defineFunction(fn.distinct, '<x:x>'));\n    staticFrame.bind('base64encode', defineFunction(fn.base64encode, '<s-:s>'));\n    staticFrame.bind('base64decode', defineFunction(fn.base64decode, '<s-:s>'));\n    staticFrame.bind('encodeUrlComponent', defineFunction(fn.encodeUrlComponent, '<s-:s>'));\n    staticFrame.bind('encodeUrl', defineFunction(fn.encodeUrl, '<s-:s>'));\n    staticFrame.bind('decodeUrlComponent', defineFunction(fn.decodeUrlComponent, '<s-:s>'));\n    staticFrame.bind('decodeUrl', defineFunction(fn.decodeUrl, '<s-:s>'));\n    staticFrame.bind('eval', defineFunction(functionEval, '<sx?:x>'));\n    staticFrame.bind('toMillis', defineFunction(datetime.toMillis, '<s-s?:n>'));\n    staticFrame.bind('fromMillis', defineFunction(datetime.fromMillis, '<n-s?s?:s>'));\n    staticFrame.bind('clone', defineFunction(functionClone, '<(oa)-:o>'));\n\n    /**\n     * Error codes\n     *\n     * Sxxxx    - Static errors (compile time)\n     * Txxxx    - Type errors\n     * Dxxxx    - Dynamic errors (evaluate time)\n     *  01xx    - tokenizer\n     *  02xx    - parser\n     *  03xx    - regex parser\n     *  04xx    - function signature parser/evaluator\n     *  10xx    - evaluator\n     *  20xx    - operators\n     *  3xxx    - functions (blocks of 10 for each function)\n     */\n    var errorCodes = {\n        \"S0101\": \"String literal must be terminated by a matching quote\",\n        \"S0102\": \"Number out of range: {{token}}\",\n        \"S0103\": \"Unsupported escape sequence: \\\\{{token}}\",\n        \"S0104\": \"The escape sequence \\\\u must be followed by 4 hex digits\",\n        \"S0105\": \"Quoted property name must be terminated with a backquote (`)\",\n        \"S0106\": \"Comment has no closing tag\",\n        \"S0201\": \"Syntax error: {{token}}\",\n        \"S0202\": \"Expected {{value}}, got {{token}}\",\n        \"S0203\": \"Expected {{value}} before end of expression\",\n        \"S0204\": \"Unknown operator: {{token}}\",\n        \"S0205\": \"Unexpected token: {{token}}\",\n        \"S0206\": \"Unknown expression type: {{token}}\",\n        \"S0207\": \"Unexpected end of expression\",\n        \"S0208\": \"Parameter {{value}} of function definition must be a variable name (start with $)\",\n        \"S0209\": \"A predicate cannot follow a grouping expression in a step\",\n        \"S0210\": \"Each step can only have one grouping expression\",\n        \"S0211\": \"The symbol {{token}} cannot be used as a unary operator\",\n        \"S0212\": \"The left side of := must be a variable name (start with $)\",\n        \"S0213\": \"The literal value {{value}} cannot be used as a step within a path expression\",\n        \"S0214\": \"The right side of {{token}} must be a variable name (start with $)\",\n        \"S0215\": \"A context variable binding must precede any predicates on a step\",\n        \"S0216\": \"A context variable binding must precede the 'order-by' clause on a step\",\n        \"S0217\": \"The object representing the 'parent' cannot be derived from this expression\",\n        \"S0301\": \"Empty regular expressions are not allowed\",\n        \"S0302\": \"No terminating / in regular expression\",\n        \"S0402\": \"Choice groups containing parameterized types are not supported\",\n        \"S0401\": \"Type parameters can only be applied to functions and arrays\",\n        \"S0500\": \"Attempted to evaluate an expression containing syntax error(s)\",\n        \"T0410\": \"Argument {{index}} of function {{token}} does not match function signature\",\n        \"T0411\": \"Context value is not a compatible type with argument {{index}} of function {{token}}\",\n        \"T0412\": \"Argument {{index}} of function {{token}} must be an array of {{type}}\",\n        \"D1001\": \"Number out of range: {{value}}\",\n        \"D1002\": \"Cannot negate a non-numeric value: {{value}}\",\n        \"T1003\": \"Key in object structure must evaluate to a string; got: {{value}}\",\n        \"D1004\": \"Regular expression matches zero length string\",\n        \"T1005\": \"Attempted to invoke a non-function. Did you mean ${{{token}}}?\",\n        \"T1006\": \"Attempted to invoke a non-function\",\n        \"T1007\": \"Attempted to partially apply a non-function. Did you mean ${{{token}}}?\",\n        \"T1008\": \"Attempted to partially apply a non-function\",\n        \"D1009\": \"Multiple key definitions evaluate to same key: {{value}}\",\n        \"D1010\": \"Attempted to access the Javascript object prototype\", // Javascript specific \n        \"T1010\": \"The matcher function argument passed to function {{token}} does not return the correct object structure\",\n        \"T2001\": \"The left side of the {{token}} operator must evaluate to a number\",\n        \"T2002\": \"The right side of the {{token}} operator must evaluate to a number\",\n        \"T2003\": \"The left side of the range operator (..) must evaluate to an integer\",\n        \"T2004\": \"The right side of the range operator (..) must evaluate to an integer\",\n        \"D2005\": \"The left side of := must be a variable name (start with $)\",  // defunct - replaced by S0212 parser error\n        \"T2006\": \"The right side of the function application operator ~> must be a function\",\n        \"T2007\": \"Type mismatch when comparing values {{value}} and {{value2}} in order-by clause\",\n        \"T2008\": \"The expressions within an order-by clause must evaluate to numeric or string values\",\n        \"T2009\": \"The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type\",\n        \"T2010\": \"The expressions either side of operator {{token}} must evaluate to numeric or string values\",\n        \"T2011\": \"The insert/update clause of the transform expression must evaluate to an object: {{value}}\",\n        \"T2012\": \"The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}\",\n        \"T2013\": \"The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.\",\n        \"D2014\": \"The size of the sequence allocated by the range operator (..) must not exceed 1e6.  Attempted to allocate {{value}}.\",\n        \"D3001\": \"Attempting to invoke string function on Infinity or NaN\",\n        \"D3010\": \"Second argument of replace function cannot be an empty string\",\n        \"D3011\": \"Fourth argument of replace function must evaluate to a positive number\",\n        \"D3012\": \"Attempted to replace a matched string with a non-string value\",\n        \"D3020\": \"Third argument of split function must evaluate to a positive number\",\n        \"D3030\": \"Unable to cast value to a number: {{value}}\",\n        \"D3040\": \"Third argument of match function must evaluate to a positive number\",\n        \"D3050\": \"The second argument of reduce function must be a function with at least two arguments\",\n        \"D3060\": \"The sqrt function cannot be applied to a negative number: {{value}}\",\n        \"D3061\": \"The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}\",\n        \"D3070\": \"The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function\",\n        \"D3080\": \"The picture string must only contain a maximum of two sub-pictures\",\n        \"D3081\": \"The sub-picture must not contain more than one instance of the 'decimal-separator' character\",\n        \"D3082\": \"The sub-picture must not contain more than one instance of the 'percent' character\",\n        \"D3083\": \"The sub-picture must not contain more than one instance of the 'per-mille' character\",\n        \"D3084\": \"The sub-picture must not contain both a 'percent' and a 'per-mille' character\",\n        \"D3085\": \"The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'\",\n        \"D3086\": \"The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character\",\n        \"D3087\": \"The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character\",\n        \"D3088\": \"The sub-picture must not contain a 'grouping-separator' at the end of the integer part\",\n        \"D3089\": \"The sub-picture must not contain two adjacent instances of the 'grouping-separator' character\",\n        \"D3090\": \"The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'\",\n        \"D3091\": \"The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'\",\n        \"D3092\": \"A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'\",\n        \"D3093\": \"The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'\",\n        \"D3100\": \"The radix of the formatBase function must be between 2 and 36.  It was given {{value}}\",\n        \"D3110\": \"The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}\",\n        \"D3120\": \"Syntax error in expression passed to function eval: {{value}}\",\n        \"D3121\": \"Dynamic error evaluating the expression passed to function eval: {{value}}\",\n        \"D3130\": \"Formatting or parsing an integer as a sequence starting with {{value}} is not supported by this implementation\",\n        \"D3131\": \"In a decimal digit pattern, all digits must be from the same decimal group\",\n        \"D3132\": \"Unknown component specifier {{value}} in date/time picture string\",\n        \"D3133\": \"The 'name' modifier can only be applied to months and days in the date/time picture string, not {{value}}\",\n        \"D3134\": \"The timezone integer format specifier cannot have more than four digits\",\n        \"D3135\": \"No matching closing bracket ']' in date/time picture string\",\n        \"D3136\": \"The date/time picture string is missing specifiers required to parse the timestamp\",\n        \"D3137\": \"{{{message}}}\",\n        \"D3138\": \"The $single() function expected exactly 1 matching result.  Instead it matched more.\",\n        \"D3139\": \"The $single() function expected exactly 1 matching result.  Instead it matched 0.\",\n        \"D3140\": \"Malformed URL passed to ${{{functionName}}}(): {{value}}\",\n        \"D3141\": \"{{{message}}}\"\n    };\n\n    /**\n     * lookup a message template from the catalog and substitute the inserts.\n     * Populates `err.message` with the substituted message. Leaves `err.message`\n     * untouched if code lookup fails.\n     * @param {string} err - error code to lookup\n     * @returns {undefined} - `err` is modified in place\n     */\n    function populateMessage(err) {\n        var template = errorCodes[err.code];\n        if(typeof template !== 'undefined') {\n            // if there are any handlebars, replace them with the field references\n            // triple braces - replace with value\n            // double braces - replace with json stringified value\n            var message = template.replace(/\\{\\{\\{([^}]+)}}}/g, function() {\n                return err[arguments[1]];\n            });\n            message = message.replace(/\\{\\{([^}]+)}}/g, function() {\n                return JSON.stringify(err[arguments[1]]);\n            });\n            err.message = message;\n        }\n        // Otherwise retain the original `err.message`\n    }\n\n    /**\n     * JSONata\n     * @param {Object} expr - JSONata expression\n     * @param {Object} options\n     * @param {boolean} options.recover: attempt to recover on parse error\n     * @param {Function} options.RegexEngine: RegEx class constructor to use\n     * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression\n     */\n    function jsonata(expr, options) {\n        var ast;\n        var errors;\n        try {\n            ast = parser(expr, options && options.recover);\n            errors = ast.errors;\n            delete ast.errors;\n        } catch(err) {\n            // insert error message into structure\n            populateMessage(err); // possible side-effects on `err`\n            throw err;\n        }\n        var environment = createFrame(staticFrame);\n\n        var timestamp = new Date(); // will be overridden on each call to evalute()\n        environment.bind('now', defineFunction(function(picture, timezone) {\n            return datetime.fromMillis(timestamp.getTime(), picture, timezone);\n        }, '<s?s?:s>'));\n        environment.bind('millis', defineFunction(function() {\n            return timestamp.getTime();\n        }, '<:n>'));\n\n        if(options && options.RegexEngine) {\n            jsonata.RegexEngine = options.RegexEngine;\n        } else {\n            jsonata.RegexEngine = RegExp;\n        }\n\n        return {\n            evaluate: async function (input, bindings, callback) {\n                // throw if the expression compiled with syntax errors\n                if(typeof errors !== 'undefined') {\n                    var err = {\n                        code: 'S0500',\n                        position: 0\n                    };\n                    populateMessage(err); // possible side-effects on `err`\n                    throw err;\n                }\n\n                if (typeof bindings !== 'undefined') {\n                    var exec_env;\n                    // the variable bindings have been passed in - create a frame to hold these\n                    exec_env = createFrame(environment);\n                    for (var v in bindings) {\n                        exec_env.bind(v, bindings[v]);\n                    }\n                } else {\n                    exec_env = environment;\n                }\n                // put the input document into the environment as the root object\n                exec_env.bind('$', input);\n\n                // capture the timestamp and put it in the execution environment\n                // the $now() and $millis() functions will return this value - whenever it is called\n                timestamp = new Date();\n                exec_env.timestamp = timestamp;\n\n                // if the input is a JSON array, then wrap it in a singleton sequence so it gets treated as a single input\n                if(Array.isArray(input) && !isSequence(input)) {\n                    input = createSequence(input);\n                    input.outerWrapper = true;\n                }\n\n                var it;\n                try {\n                    it = await evaluate(ast, input, exec_env);\n                    if (typeof callback === \"function\") {\n                        callback(null, it);\n                    }\n                    return it;\n                } catch (err) {\n                    // insert error message into structure\n                    populateMessage(err); // possible side-effects on `err`\n                    throw err;\n                }\n            },\n            assign: function (name, value) {\n                environment.bind(name, value);\n            },\n            registerFunction: function(name, implementation, signature) {\n                var func = defineFunction(implementation, signature);\n                environment.bind(name, func);\n            },\n            ast: function() {\n                return ast;\n            },\n            errors: function() {\n                return errors;\n            }\n        };\n    }\n\n    jsonata.parser = parser; // TODO remove this in a future release - use ast() instead\n\n    return jsonata;\n\n})();\n\nmodule.exports = jsonata;\n\n},{\"./datetime\":1,\"./functions\":2,\"./parser\":4,\"./signature\":5,\"./utils\":6}],4:[function(require,module,exports){\n/**\n *  Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nvar parseSignature = require('./signature');\n\nconst parser = (() => {\n    'use strict';\n\n    var operators = {\n        '.': 75,\n        '[': 80,\n        ']': 0,\n        '{': 70,\n        '}': 0,\n        '(': 80,\n        ')': 0,\n        ',': 0,\n        '@': 80,\n        '#': 80,\n        ';': 80,\n        ':': 80,\n        '?': 20,\n        '+': 50,\n        '-': 50,\n        '*': 60,\n        '/': 60,\n        '%': 60,\n        '|': 20,\n        '=': 40,\n        '<': 40,\n        '>': 40,\n        '^': 40,\n        '**': 60,\n        '..': 20,\n        ':=': 10,\n        '!=': 40,\n        '<=': 40,\n        '>=': 40,\n        '~>': 40,\n        'and': 30,\n        'or': 25,\n        'in': 40,\n        '&': 50,\n        '!': 0,   // not an operator, but needed as a stop character for name tokens\n        '~': 0   // not an operator, but needed as a stop character for name tokens\n    };\n\n    var escapes = {  // JSON string escape sequences - see json.org\n        '\"': '\"',\n        '\\\\': '\\\\',\n        '/': '/',\n        'b': '\\b',\n        'f': '\\f',\n        'n': '\\n',\n        'r': '\\r',\n        't': '\\t'\n    };\n\n    // Tokenizer (lexer) - invoked by the parser to return one token at a time\n    var tokenizer = function (path) {\n        var position = 0;\n        var length = path.length;\n\n        var create = function (type, value) {\n            var obj = {type: type, value: value, position: position};\n            return obj;\n        };\n\n        var scanRegex = function () {\n            // the prefix '/' will have been previously scanned. Find the end of the regex.\n            // search for closing '/' ignoring any that are escaped, or within brackets\n            var start = position;\n            var depth = 0;\n            var pattern;\n            var flags;\n\n            var isClosingSlash = function (position) {\n                if (path.charAt(position) === '/' && depth === 0) {\n                    var backslashCount = 0;\n                    while (path.charAt(position - (backslashCount + 1)) === '\\\\') {\n                        backslashCount++;\n                    }\n                    if (backslashCount % 2 === 0) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n\n            while (position < length) {\n                var currentChar = path.charAt(position);\n                if (isClosingSlash(position)) {\n                    // end of regex found\n                    pattern = path.substring(start, position);\n                    if (pattern === '') {\n                        throw {\n                            code: \"S0301\",\n                            stack: (new Error()).stack,\n                            position: position\n                        };\n                    }\n                    position++;\n                    currentChar = path.charAt(position);\n                    // flags\n                    start = position;\n                    while (currentChar === 'i' || currentChar === 'm') {\n                        position++;\n                        currentChar = path.charAt(position);\n                    }\n                    flags = path.substring(start, position) + 'g';\n                    return new RegExp(pattern, flags);\n                }\n                if ((currentChar === '(' || currentChar === '[' || currentChar === '{') && path.charAt(position - 1) !== '\\\\') {\n                    depth++;\n                }\n                if ((currentChar === ')' || currentChar === ']' || currentChar === '}') && path.charAt(position - 1) !== '\\\\') {\n                    depth--;\n                }\n\n                position++;\n            }\n            throw {\n                code: \"S0302\",\n                stack: (new Error()).stack,\n                position: position\n            };\n        };\n\n        var next = function (prefix) {\n            if (position >= length) return null;\n            var currentChar = path.charAt(position);\n            // skip whitespace\n            while (position < length && ' \\t\\n\\r\\v'.indexOf(currentChar) > -1) {\n                position++;\n                currentChar = path.charAt(position);\n            }\n            // skip comments\n            if (currentChar === '/' && path.charAt(position + 1) === '*') {\n                var commentStart = position;\n                position += 2;\n                currentChar = path.charAt(position);\n                while (!(currentChar === '*' && path.charAt(position + 1) === '/')) {\n                    currentChar = path.charAt(++position);\n                    if (position >= length) {\n                        // no closing tag\n                        throw {\n                            code: \"S0106\",\n                            stack: (new Error()).stack,\n                            position: commentStart\n                        };\n                    }\n                }\n                position += 2;\n                currentChar = path.charAt(position);\n                return next(prefix); // need this to swallow any following whitespace\n            }\n            // test for regex\n            if (prefix !== true && currentChar === '/') {\n                position++;\n                return create('regex', scanRegex());\n            }\n            // handle double-char operators\n            if (currentChar === '.' && path.charAt(position + 1) === '.') {\n                // double-dot .. range operator\n                position += 2;\n                return create('operator', '..');\n            }\n            if (currentChar === ':' && path.charAt(position + 1) === '=') {\n                // := assignment\n                position += 2;\n                return create('operator', ':=');\n            }\n            if (currentChar === '!' && path.charAt(position + 1) === '=') {\n                // !=\n                position += 2;\n                return create('operator', '!=');\n            }\n            if (currentChar === '>' && path.charAt(position + 1) === '=') {\n                // >=\n                position += 2;\n                return create('operator', '>=');\n            }\n            if (currentChar === '<' && path.charAt(position + 1) === '=') {\n                // <=\n                position += 2;\n                return create('operator', '<=');\n            }\n            if (currentChar === '*' && path.charAt(position + 1) === '*') {\n                // **  descendant wildcard\n                position += 2;\n                return create('operator', '**');\n            }\n            if (currentChar === '~' && path.charAt(position + 1) === '>') {\n                // ~>  chain function\n                position += 2;\n                return create('operator', '~>');\n            }\n            // test for single char operators\n            if (Object.prototype.hasOwnProperty.call(operators, currentChar)) {\n                position++;\n                return create('operator', currentChar);\n            }\n            // test for string literals\n            if (currentChar === '\"' || currentChar === \"'\") {\n                var quoteType = currentChar;\n                // double quoted string literal - find end of string\n                position++;\n                var qstr = \"\";\n                while (position < length) {\n                    currentChar = path.charAt(position);\n                    if (currentChar === '\\\\') { // escape sequence\n                        position++;\n                        currentChar = path.charAt(position);\n                        if (Object.prototype.hasOwnProperty.call(escapes, currentChar)) {\n                            qstr += escapes[currentChar];\n                        } else if (currentChar === 'u') {\n                            // \\u should be followed by 4 hex digits\n                            var octets = path.substr(position + 1, 4);\n                            if (/^[0-9a-fA-F]+$/.test(octets)) {\n                                var codepoint = parseInt(octets, 16);\n                                qstr += String.fromCharCode(codepoint);\n                                position += 4;\n                            } else {\n                                throw {\n                                    code: \"S0104\",\n                                    stack: (new Error()).stack,\n                                    position: position\n                                };\n                            }\n                        } else {\n                            // illegal escape sequence\n                            throw {\n                                code: \"S0103\",\n                                stack: (new Error()).stack,\n                                position: position,\n                                token: currentChar\n                            };\n\n                        }\n                    } else if (currentChar === quoteType) {\n                        position++;\n                        return create('string', qstr);\n                    } else {\n                        qstr += currentChar;\n                    }\n                    position++;\n                }\n                throw {\n                    code: \"S0101\",\n                    stack: (new Error()).stack,\n                    position: position\n                };\n            }\n            // test for numbers\n            var numregex = /^-?(0|([1-9][0-9]*))(\\.[0-9]+)?([Ee][-+]?[0-9]+)?/;\n            var match = numregex.exec(path.substring(position));\n            if (match !== null) {\n                var num = parseFloat(match[0]);\n                if (!isNaN(num) && isFinite(num)) {\n                    position += match[0].length;\n                    return create('number', num);\n                } else {\n                    throw {\n                        code: \"S0102\",\n                        stack: (new Error()).stack,\n                        position: position,\n                        token: match[0]\n                    };\n                }\n            }\n            // test for quoted names (backticks)\n            var name;\n            if (currentChar === '`') {\n                // scan for closing quote\n                position++;\n                var end = path.indexOf('`', position);\n                if (end !== -1) {\n                    name = path.substring(position, end);\n                    position = end + 1;\n                    return create('name', name);\n                }\n                position = length;\n                throw {\n                    code: \"S0105\",\n                    stack: (new Error()).stack,\n                    position: position\n                };\n            }\n            // test for names\n            var i = position;\n            var ch;\n            for (; ;) {\n                ch = path.charAt(i);\n                if (i === length || ' \\t\\n\\r\\v'.indexOf(ch) > -1 || Object.prototype.hasOwnProperty.call(operators, ch)) {\n                    if (path.charAt(position) === '$') {\n                        // variable reference\n                        name = path.substring(position + 1, i);\n                        position = i;\n                        return create('variable', name);\n                    } else {\n                        name = path.substring(position, i);\n                        position = i;\n                        switch (name) {\n                            case 'or':\n                            case 'in':\n                            case 'and':\n                                return create('operator', name);\n                            case 'true':\n                                return create('value', true);\n                            case 'false':\n                                return create('value', false);\n                            case 'null':\n                                return create('value', null);\n                            default:\n                                if (position === length && name === '') {\n                                    // whitespace at end of input\n                                    return null;\n                                }\n                                return create('name', name);\n                        }\n                    }\n                } else {\n                    i++;\n                }\n            }\n        };\n\n        return next;\n    };\n\n    // This parser implements the 'Top down operator precedence' algorithm developed by Vaughan R Pratt; http://dl.acm.org/citation.cfm?id=512931.\n    // and builds on the Javascript framework described by Douglas Crockford at http://javascript.crockford.com/tdop/tdop.html\n    // and in 'Beautiful Code', edited by Andy Oram and Greg Wilson, Copyright 2007 O'Reilly Media, Inc. 798-0-596-51004-6\n\n    var parser = function (source, recover) {\n        var node;\n        var lexer;\n\n        var symbol_table = {};\n        var errors = [];\n\n        var remainingTokens = function () {\n            var remaining = [];\n            if (node.id !== '(end)') {\n                remaining.push({type: node.type, value: node.value, position: node.position});\n            }\n            var nxt = lexer();\n            while (nxt !== null) {\n                remaining.push(nxt);\n                nxt = lexer();\n            }\n            return remaining;\n        };\n\n        var base_symbol = {\n            nud: function () {\n                // error - symbol has been invoked as a unary operator\n                var err = {\n                    code: 'S0211',\n                    token: this.value,\n                    position: this.position\n                };\n\n                if (recover) {\n                    err.remaining = remainingTokens();\n                    err.type = 'error';\n                    errors.push(err);\n                    return err;\n                } else {\n                    err.stack = (new Error()).stack;\n                    throw err;\n                }\n            }\n        };\n\n        var symbol = function (id, bp) {\n            var s = symbol_table[id];\n            bp = bp || 0;\n            if (s) {\n                if (bp >= s.lbp) {\n                    s.lbp = bp;\n                }\n            } else {\n                s = Object.create(base_symbol);\n                s.id = s.value = id;\n                s.lbp = bp;\n                symbol_table[id] = s;\n            }\n            return s;\n        };\n\n        var handleError = function (err) {\n            if (recover) {\n                // tokenize the rest of the buffer and add it to an error token\n                err.remaining = remainingTokens();\n                errors.push(err);\n                var symbol = symbol_table[\"(error)\"];\n                node = Object.create(symbol);\n                node.error = err;\n                node.type = \"(error)\";\n                return node;\n            } else {\n                err.stack = (new Error()).stack;\n                throw err;\n            }\n        };\n\n        var advance = function (id, infix) {\n            if (id && node.id !== id) {\n                var code;\n                if (node.id === '(end)') {\n                    // unexpected end of buffer\n                    code = \"S0203\";\n                } else {\n                    code = \"S0202\";\n                }\n                var err = {\n                    code: code,\n                    position: node.position,\n                    token: node.value,\n                    value: id\n                };\n                return handleError(err);\n            }\n            var next_token = lexer(infix);\n            if (next_token === null) {\n                node = symbol_table[\"(end)\"];\n                node.position = source.length;\n                return node;\n            }\n            var value = next_token.value;\n            var type = next_token.type;\n            var symbol;\n            switch (type) {\n                case 'name':\n                case 'variable':\n                    symbol = symbol_table[\"(name)\"];\n                    break;\n                case 'operator':\n                    symbol = symbol_table[value];\n                    if (!symbol) {\n                        return handleError({\n                            code: \"S0204\",\n                            stack: (new Error()).stack,\n                            position: next_token.position,\n                            token: value\n                        });\n                    }\n                    break;\n                case 'string':\n                case 'number':\n                case 'value':\n                    symbol = symbol_table[\"(literal)\"];\n                    break;\n                case 'regex':\n                    type = \"regex\";\n                    symbol = symbol_table[\"(regex)\"];\n                    break;\n                /* istanbul ignore next */\n                default:\n                    return handleError({\n                        code: \"S0205\",\n                        stack: (new Error()).stack,\n                        position: next_token.position,\n                        token: value\n                    });\n            }\n\n            node = Object.create(symbol);\n            node.value = value;\n            node.type = type;\n            node.position = next_token.position;\n            return node;\n        };\n\n        // Pratt's algorithm\n        var expression = function (rbp) {\n            var left;\n            var t = node;\n            advance(null, true);\n            left = t.nud();\n            while (rbp < node.lbp) {\n                t = node;\n                advance();\n                left = t.led(left);\n            }\n            return left;\n        };\n\n        var terminal = function (id) {\n            var s = symbol(id, 0);\n            s.nud = function () {\n                return this;\n            };\n        };\n\n        // match infix operators\n        // <expression> <operator> <expression>\n        // left associative\n        var infix = function (id, bp, led) {\n            var bindingPower = bp || operators[id];\n            var s = symbol(id, bindingPower);\n            s.led = led || function (left) {\n                this.lhs = left;\n                this.rhs = expression(bindingPower);\n                this.type = \"binary\";\n                return this;\n            };\n            return s;\n        };\n\n        // match infix operators\n        // <expression> <operator> <expression>\n        // right associative\n        var infixr = function (id, bp, led) {\n            var s = symbol(id, bp);\n            s.led = led;\n            return s;\n        };\n\n        // match prefix operators\n        // <operator> <expression>\n        var prefix = function (id, nud) {\n            var s = symbol(id);\n            s.nud = nud || function () {\n                this.expression = expression(70);\n                this.type = \"unary\";\n                return this;\n            };\n            return s;\n        };\n\n        terminal(\"(end)\");\n        terminal(\"(name)\");\n        terminal(\"(literal)\");\n        terminal(\"(regex)\");\n        symbol(\":\");\n        symbol(\";\");\n        symbol(\",\");\n        symbol(\")\");\n        symbol(\"]\");\n        symbol(\"}\");\n        symbol(\"..\"); // range operator\n        infix(\".\"); // map operator\n        infix(\"+\"); // numeric addition\n        infix(\"-\"); // numeric subtraction\n        infix(\"*\"); // numeric multiplication\n        infix(\"/\"); // numeric division\n        infix(\"%\"); // numeric modulus\n        infix(\"=\"); // equality\n        infix(\"<\"); // less than\n        infix(\">\"); // greater than\n        infix(\"!=\"); // not equal to\n        infix(\"<=\"); // less than or equal\n        infix(\">=\"); // greater than or equal\n        infix(\"&\"); // string concatenation\n        infix(\"and\"); // Boolean AND\n        infix(\"or\"); // Boolean OR\n        infix(\"in\"); // is member of array\n        terminal(\"and\"); // the 'keywords' can also be used as terminals (field names)\n        terminal(\"or\"); //\n        terminal(\"in\"); //\n        prefix(\"-\"); // unary numeric negation\n        infix(\"~>\"); // function application\n\n        infixr(\"(error)\", 10, function (left) {\n            this.lhs = left;\n\n            this.error = node.error;\n            this.remaining = remainingTokens();\n            this.type = 'error';\n            return this;\n        });\n\n        // field wildcard (single level)\n        prefix('*', function () {\n            this.type = \"wildcard\";\n            return this;\n        });\n\n        // descendant wildcard (multi-level)\n        prefix('**', function () {\n            this.type = \"descendant\";\n            return this;\n        });\n\n        // parent operator\n        prefix('%', function () {\n            this.type = \"parent\";\n            return this;\n        });\n\n        // function invocation\n        infix(\"(\", operators['('], function (left) {\n            // left is is what we are trying to invoke\n            this.procedure = left;\n            this.type = 'function';\n            this.arguments = [];\n            if (node.id !== ')') {\n                for (; ;) {\n                    if (node.type === 'operator' && node.id === '?') {\n                        // partial function application\n                        this.type = 'partial';\n                        this.arguments.push(node);\n                        advance('?');\n                    } else {\n                        this.arguments.push(expression(0));\n                    }\n                    if (node.id !== ',') break;\n                    advance(',');\n                }\n            }\n            advance(\")\", true);\n            // if the name of the function is 'function' or , then this is function definition (lambda function)\n            if (left.type === 'name' && (left.value === 'function' || left.value === '\\u03BB')) {\n                // all of the args must be VARIABLE tokens\n                this.arguments.forEach(function (arg, index) {\n                    if (arg.type !== 'variable') {\n                        return handleError({\n                            code: \"S0208\",\n                            stack: (new Error()).stack,\n                            position: arg.position,\n                            token: arg.value,\n                            value: index + 1\n                        });\n                    }\n                });\n                this.type = 'lambda';\n                // is the next token a '<' - if so, parse the function signature\n                if (node.id === '<') {\n                    var sigPos = node.position;\n                    var depth = 1;\n                    var sig = '<';\n                    while (depth > 0 && node.id !== '{' && node.id !== '(end)') {\n                        var tok = advance();\n                        if (tok.id === '>') {\n                            depth--;\n                        } else if (tok.id === '<') {\n                            depth++;\n                        }\n                        sig += tok.value;\n                    }\n                    advance('>');\n                    try {\n                        this.signature = parseSignature(sig);\n                    } catch (err) {\n                        // insert the position into this error\n                        err.position = sigPos + err.offset;\n                        return handleError(err);\n                    }\n                }\n                // parse the function body\n                advance('{');\n                this.body = expression(0);\n                advance('}');\n            }\n            return this;\n        });\n\n        // parenthesis - block expression\n        prefix(\"(\", function () {\n            var expressions = [];\n            while (node.id !== \")\") {\n                expressions.push(expression(0));\n                if (node.id !== \";\") {\n                    break;\n                }\n                advance(\";\");\n            }\n            advance(\")\", true);\n            this.type = 'block';\n            this.expressions = expressions;\n            return this;\n        });\n\n        // array constructor\n        prefix(\"[\", function () {\n            var a = [];\n            if (node.id !== \"]\") {\n                for (; ;) {\n                    var item = expression(0);\n                    if (node.id === \"..\") {\n                        // range operator\n                        var range = {type: \"binary\", value: \"..\", position: node.position, lhs: item};\n                        advance(\"..\");\n                        range.rhs = expression(0);\n                        item = range;\n                    }\n                    a.push(item);\n                    if (node.id !== \",\") {\n                        break;\n                    }\n                    advance(\",\");\n                }\n            }\n            advance(\"]\", true);\n            this.expressions = a;\n            this.type = \"unary\";\n            return this;\n        });\n\n        // filter - predicate or array index\n        infix(\"[\", operators['['], function (left) {\n            if (node.id === \"]\") {\n                // empty predicate means maintain singleton arrays in the output\n                var step = left;\n                while (step && step.type === 'binary' && step.value === '[') {\n                    step = step.lhs;\n                }\n                step.keepArray = true;\n                advance(\"]\");\n                return left;\n            } else {\n                this.lhs = left;\n                this.rhs = expression(operators[']']);\n                this.type = 'binary';\n                advance(\"]\", true);\n                return this;\n            }\n        });\n\n        // order-by\n        infix(\"^\", operators['^'], function (left) {\n            advance(\"(\");\n            var terms = [];\n            for (; ;) {\n                var term = {\n                    descending: false\n                };\n                if (node.id === \"<\") {\n                    // ascending sort\n                    advance(\"<\");\n                } else if (node.id === \">\") {\n                    // descending sort\n                    term.descending = true;\n                    advance(\">\");\n                } else {\n                    //unspecified - default to ascending\n                }\n                term.expression = expression(0);\n                terms.push(term);\n                if (node.id !== \",\") {\n                    break;\n                }\n                advance(\",\");\n            }\n            advance(\")\");\n            this.lhs = left;\n            this.rhs = terms;\n            this.type = 'binary';\n            return this;\n        });\n\n        var objectParser = function (left) {\n            var a = [];\n            if (node.id !== \"}\") {\n                for (; ;) {\n                    var n = expression(0);\n                    advance(\":\");\n                    var v = expression(0);\n                    a.push([n, v]); // holds an array of name/value expression pairs\n                    if (node.id !== \",\") {\n                        break;\n                    }\n                    advance(\",\");\n                }\n            }\n            advance(\"}\", true);\n            if (typeof left === 'undefined') {\n                // NUD - unary prefix form\n                this.lhs = a;\n                this.type = \"unary\";\n            } else {\n                // LED - binary infix form\n                this.lhs = left;\n                this.rhs = a;\n                this.type = 'binary';\n            }\n            return this;\n        };\n\n        // object constructor\n        prefix(\"{\", objectParser);\n\n        // object grouping\n        infix(\"{\", operators['{'], objectParser);\n\n        // bind variable\n        infixr(\":=\", operators[':='], function (left) {\n            if (left.type !== 'variable') {\n                return handleError({\n                    code: \"S0212\",\n                    stack: (new Error()).stack,\n                    position: left.position,\n                    token: left.value\n                });\n            }\n            this.lhs = left;\n            this.rhs = expression(operators[':='] - 1); // subtract 1 from bindingPower for right associative operators\n            this.type = \"binary\";\n            return this;\n        });\n\n        // focus variable bind\n        infix(\"@\", operators['@'], function (left) {\n            this.lhs = left;\n            this.rhs = expression(operators['@']);\n            if(this.rhs.type !== 'variable') {\n                return handleError({\n                    code: \"S0214\",\n                    stack: (new Error()).stack,\n                    position: this.rhs.position,\n                    token: \"@\"\n                });\n            }\n            this.type = \"binary\";\n            return this;\n        });\n\n        // index (position) variable bind\n        infix(\"#\", operators['#'], function (left) {\n            this.lhs = left;\n            this.rhs = expression(operators['#']);\n            if(this.rhs.type !== 'variable') {\n                return handleError({\n                    code: \"S0214\",\n                    stack: (new Error()).stack,\n                    position: this.rhs.position,\n                    token: \"#\"\n                });\n            }\n            this.type = \"binary\";\n            return this;\n        });\n\n        // if/then/else ternary operator ?:\n        infix(\"?\", operators['?'], function (left) {\n            this.type = 'condition';\n            this.condition = left;\n            this.then = expression(0);\n            if (node.id === ':') {\n                // else condition\n                advance(\":\");\n                this.else = expression(0);\n            }\n            return this;\n        });\n\n        // object transformer\n        prefix(\"|\", function () {\n            this.type = 'transform';\n            this.pattern = expression(0);\n            advance('|');\n            this.update = expression(0);\n            if (node.id === ',') {\n                advance(',');\n                this.delete = expression(0);\n            }\n            advance('|');\n            return this;\n        });\n\n        // tail call optimization\n        // this is invoked by the post parser to analyse lambda functions to see\n        // if they make a tail call.  If so, it is replaced by a thunk which will\n        // be invoked by the trampoline loop during function application.\n        // This enables tail-recursive functions to be written without growing the stack\n        var tailCallOptimize = function (expr) {\n            var result;\n            if (expr.type === 'function' && !expr.predicate) {\n                var thunk = {type: 'lambda', thunk: true, arguments: [], position: expr.position};\n                thunk.body = expr;\n                result = thunk;\n            } else if (expr.type === 'condition') {\n                // analyse both branches\n                expr.then = tailCallOptimize(expr.then);\n                if (typeof expr.else !== 'undefined') {\n                    expr.else = tailCallOptimize(expr.else);\n                }\n                result = expr;\n            } else if (expr.type === 'block') {\n                // only the last expression in the block\n                var length = expr.expressions.length;\n                if (length > 0) {\n                    expr.expressions[length - 1] = tailCallOptimize(expr.expressions[length - 1]);\n                }\n                result = expr;\n            } else {\n                result = expr;\n            }\n            return result;\n        };\n\n        var ancestorLabel = 0;\n        var ancestorIndex = 0;\n        var ancestry = [];\n\n        var seekParent = function (node, slot) {\n            switch (node.type) {\n                case 'name':\n                case 'wildcard':\n                    slot.level--;\n                    if(slot.level === 0) {\n                        if (typeof node.ancestor === 'undefined') {\n                            node.ancestor = slot;\n                        } else {\n                            // reuse the existing label\n                            ancestry[slot.index].slot.label = node.ancestor.label;\n                            node.ancestor = slot;\n                        }\n                        node.tuple = true;\n                    }\n                    break;\n                case 'parent':\n                    slot.level++;\n                    break;\n                case 'block':\n                    // look in last expression in the block\n                    if(node.expressions.length > 0) {\n                        node.tuple = true;\n                        slot = seekParent(node.expressions[node.expressions.length - 1], slot);\n                    }\n                    break;\n                case 'path':\n                    // last step in path\n                    node.tuple = true;\n                    var index = node.steps.length - 1;\n                    slot = seekParent(node.steps[index--], slot);\n                    while (slot.level > 0 && index >= 0) {\n                        // check previous steps\n                        slot = seekParent(node.steps[index--], slot);\n                    }\n                    break;\n                default:\n                    // error - can't derive ancestor\n                    throw {\n                        code: \"S0217\",\n                        token: node.type,\n                        position: node.position\n                    };\n            }\n            return slot;\n        };\n\n        var pushAncestry = function(result, value) {\n            if(typeof value.seekingParent !== 'undefined' || value.type === 'parent') {\n                var slots = (typeof value.seekingParent !== 'undefined') ? value.seekingParent : [];\n                if (value.type === 'parent') {\n                    slots.push(value.slot);\n                }\n                if(typeof result.seekingParent === 'undefined') {\n                    result.seekingParent = slots;\n                } else {\n                    Array.prototype.push.apply(result.seekingParent, slots);\n                }\n            }\n        };\n\n        var resolveAncestry = function(path) {\n            var index = path.steps.length - 1;\n            var laststep = path.steps[index];\n            var slots = (typeof laststep.seekingParent !== 'undefined') ? laststep.seekingParent : [];\n            if (laststep.type === 'parent') {\n                slots.push(laststep.slot);\n            }\n            for(var is = 0; is < slots.length; is++) {\n                var slot = slots[is];\n                index = path.steps.length - 2;\n                while (slot.level > 0) {\n                    if (index < 0) {\n                        if(typeof path.seekingParent === 'undefined') {\n                            path.seekingParent = [slot];\n                        } else {\n                            path.seekingParent.push(slot);\n                        }\n                        break;\n                    }\n                    // try previous step\n                    var step = path.steps[index--];\n                    // multiple contiguous steps that bind the focus should be skipped\n                    while(index >= 0 && step.focus && path.steps[index].focus) {\n                        step = path.steps[index--];\n                    }\n                    slot = seekParent(step, slot);\n                }\n            }\n        };\n\n        // post-parse stage\n        // the purpose of this is to add as much semantic value to the parse tree as possible\n        // in order to simplify the work of the evaluator.\n        // This includes flattening the parts of the AST representing location paths,\n        // converting them to arrays of steps which in turn may contain arrays of predicates.\n        // following this, nodes containing '.' and '[' should be eliminated from the AST.\n        var processAST = function (expr) {\n            var result;\n            switch (expr.type) {\n                case 'binary':\n                    switch (expr.value) {\n                        case '.':\n                            var lstep = processAST(expr.lhs);\n\n                            if (lstep.type === 'path') {\n                                result = lstep;\n                            } else {\n                                result = {type: 'path', steps: [lstep]};\n                            }\n                            if(lstep.type === 'parent') {\n                                result.seekingParent = [lstep.slot];\n                            }\n                            var rest = processAST(expr.rhs);\n                            if (rest.type === 'function' &&\n                                rest.procedure.type === 'path' &&\n                                rest.procedure.steps.length === 1 &&\n                                rest.procedure.steps[0].type === 'name' &&\n                                result.steps[result.steps.length - 1].type === 'function') {\n                                // next function in chain of functions - will override a thenable\n                                result.steps[result.steps.length - 1].nextFunction = rest.procedure.steps[0].value;\n                            }\n                            if (rest.type === 'path') {\n                                Array.prototype.push.apply(result.steps, rest.steps);\n                            } else {\n                                if(typeof rest.predicate !== 'undefined') {\n                                    rest.stages = rest.predicate;\n                                    delete rest.predicate;\n                                }\n                                result.steps.push(rest);\n                            }\n                            // any steps within a path that are string literals, should be changed to 'name'\n                            result.steps.filter(function (step) {\n                                if (step.type === 'number' || step.type === 'value') {\n                                    // don't allow steps to be numbers or the values true/false/null\n                                    throw {\n                                        code: \"S0213\",\n                                        stack: (new Error()).stack,\n                                        position: step.position,\n                                        value: step.value\n                                    };\n                                }\n                                return step.type === 'string';\n                            }).forEach(function (lit) {\n                                lit.type = 'name';\n                            });\n                            // any step that signals keeping a singleton array, should be flagged on the path\n                            if (result.steps.filter(function (step) {\n                                return step.keepArray === true;\n                            }).length > 0) {\n                                result.keepSingletonArray = true;\n                            }\n                            // if first step is a path constructor, flag it for special handling\n                            var firststep = result.steps[0];\n                            if (firststep.type === 'unary' && firststep.value === '[') {\n                                firststep.consarray = true;\n                            }\n                            // if the last step is an array constructor, flag it so it doesn't flatten\n                            var laststep = result.steps[result.steps.length - 1];\n                            if (laststep.type === 'unary' && laststep.value === '[') {\n                                laststep.consarray = true;\n                            }\n                            resolveAncestry(result);\n                            break;\n                        case '[':\n                            // predicated step\n                            // LHS is a step or a predicated step\n                            // RHS is the predicate expr\n                            result = processAST(expr.lhs);\n                            var step = result;\n                            var type = 'predicate';\n                            if (result.type === 'path') {\n                                step = result.steps[result.steps.length - 1];\n                                type = 'stages';\n                            }\n                            if (typeof step.group !== 'undefined') {\n                                throw {\n                                    code: \"S0209\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            if (typeof step[type] === 'undefined') {\n                                step[type] = [];\n                            }\n                            var predicate = processAST(expr.rhs);\n                            if(typeof predicate.seekingParent !== 'undefined') {\n                                predicate.seekingParent.forEach(slot => {\n                                    if(slot.level === 1) {\n                                        seekParent(step, slot);\n                                    } else {\n                                        slot.level--;\n                                    }\n                                });\n                                pushAncestry(step, predicate);\n                            }\n                            step[type].push({type: 'filter', expr: predicate, position: expr.position});\n                            break;\n                        case '{':\n                            // group-by\n                            // LHS is a step or a predicated step\n                            // RHS is the object constructor expr\n                            result = processAST(expr.lhs);\n                            if (typeof result.group !== 'undefined') {\n                                throw {\n                                    code: \"S0210\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            // object constructor - process each pair\n                            result.group = {\n                                lhs: expr.rhs.map(function (pair) {\n                                    return [processAST(pair[0]), processAST(pair[1])];\n                                }),\n                                position: expr.position\n                            };\n                            break;\n                        case '^':\n                            // order-by\n                            // LHS is the array to be ordered\n                            // RHS defines the terms\n                            result = processAST(expr.lhs);\n                            if (result.type !== 'path') {\n                                result = {type: 'path', steps: [result]};\n                            }\n                            var sortStep = {type: 'sort', position: expr.position};\n                            sortStep.terms = expr.rhs.map(function (terms) {\n                                var expression = processAST(terms.expression);\n                                pushAncestry(sortStep, expression);\n                                return {\n                                    descending: terms.descending,\n                                    expression: expression\n                                };\n                            });\n                            result.steps.push(sortStep);\n                            resolveAncestry(result);\n                            break;\n                        case ':=':\n                            result = {type: 'bind', value: expr.value, position: expr.position};\n                            result.lhs = processAST(expr.lhs);\n                            result.rhs = processAST(expr.rhs);\n                            pushAncestry(result, result.rhs);\n                            break;\n                        case '@':\n                            result = processAST(expr.lhs);\n                            step = result;\n                            if (result.type === 'path') {\n                                step = result.steps[result.steps.length - 1];\n                            }\n                            // throw error if there are any predicates defined at this point\n                            // at this point the only type of stages can be predicates\n                            if(typeof step.stages !== 'undefined' || typeof step.predicate !== 'undefined') {\n                                throw {\n                                    code: \"S0215\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            // also throw if this is applied after an 'order-by' clause\n                            if(step.type === 'sort') {\n                                throw {\n                                    code: \"S0216\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            if(expr.keepArray) {\n                                step.keepArray = true;\n                            }\n                            step.focus = expr.rhs.value;\n                            step.tuple = true;\n                            break;\n                        case '#':\n                            result = processAST(expr.lhs);\n                            step = result;\n                            if (result.type === 'path') {\n                                step = result.steps[result.steps.length - 1];\n                            } else {\n                                result = {type: 'path', steps: [result]};\n                                if (typeof step.predicate !== 'undefined') {\n                                    step.stages = step.predicate;\n                                    delete step.predicate;\n                                }\n                            }\n                            if (typeof step.stages === 'undefined') {\n                                step.index = expr.rhs.value;\n                            } else {\n                                step.stages.push({type: 'index', value: expr.rhs.value, position: expr.position});\n                            }\n                            step.tuple = true;\n                            break;\n                        case '~>':\n                            result = {type: 'apply', value: expr.value, position: expr.position};\n                            result.lhs = processAST(expr.lhs);\n                            result.rhs = processAST(expr.rhs);\n                            result.keepArray = result.lhs.keepArray || result.rhs.keepArray;\n                            break;\n                        default:\n                            result = {type: expr.type, value: expr.value, position: expr.position};\n                            result.lhs = processAST(expr.lhs);\n                            result.rhs = processAST(expr.rhs);\n                            pushAncestry(result, result.lhs);\n                            pushAncestry(result, result.rhs);\n                    }\n                    break;\n                case 'unary':\n                    result = {type: expr.type, value: expr.value, position: expr.position};\n                    if (expr.value === '[') {\n                        // array constructor - process each item\n                        result.expressions = expr.expressions.map(function (item) {\n                            var value = processAST(item);\n                            pushAncestry(result, value);\n                            return value;\n                        });\n                    } else if (expr.value === '{') {\n                        // object constructor - process each pair\n                        result.lhs = expr.lhs.map(function (pair) {\n                            var key = processAST(pair[0]);\n                            pushAncestry(result, key);\n                            var value = processAST(pair[1]);\n                            pushAncestry(result, value);\n                            return [key, value];\n                        });\n                    } else {\n                        // all other unary expressions - just process the expression\n                        result.expression = processAST(expr.expression);\n                        // if unary minus on a number, then pre-process\n                        if (expr.value === '-' && result.expression.type === 'number') {\n                            result = result.expression;\n                            result.value = -result.value;\n                        } else {\n                            pushAncestry(result, result.expression);\n                        }\n                    }\n                    break;\n                case 'function':\n                case 'partial':\n                    result = {type: expr.type, name: expr.name, value: expr.value, position: expr.position};\n                    result.arguments = expr.arguments.map(function (arg) {\n                        var argAST = processAST(arg);\n                        pushAncestry(result, argAST);\n                        return argAST;\n                    });\n                    result.procedure = processAST(expr.procedure);\n                    break;\n                case 'lambda':\n                    result = {\n                        type: expr.type,\n                        arguments: expr.arguments,\n                        signature: expr.signature,\n                        position: expr.position\n                    };\n                    var body = processAST(expr.body);\n                    result.body = tailCallOptimize(body);\n                    break;\n                case 'condition':\n                    result = {type: expr.type, position: expr.position};\n                    result.condition = processAST(expr.condition);\n                    pushAncestry(result, result.condition);\n                    result.then = processAST(expr.then);\n                    pushAncestry(result, result.then);\n                    if (typeof expr.else !== 'undefined') {\n                        result.else = processAST(expr.else);\n                        pushAncestry(result, result.else);\n                    }\n                    break;\n                case 'transform':\n                    result = {type: expr.type, position: expr.position};\n                    result.pattern = processAST(expr.pattern);\n                    result.update = processAST(expr.update);\n                    if (typeof expr.delete !== 'undefined') {\n                        result.delete = processAST(expr.delete);\n                    }\n                    break;\n                case 'block':\n                    result = {type: expr.type, position: expr.position};\n                    // array of expressions - process each one\n                    result.expressions = expr.expressions.map(function (item) {\n                        var part = processAST(item);\n                        pushAncestry(result, part);\n                        if (part.consarray || (part.type === 'path' && part.steps[0].consarray)) {\n                            result.consarray = true;\n                        }\n                        return part;\n                    });\n                    // TODO scan the array of expressions to see if any of them assign variables\n                    // if so, need to mark the block as one that needs to create a new frame\n                    break;\n                case 'name':\n                    result = {type: 'path', steps: [expr]};\n                    if (expr.keepArray) {\n                        result.keepSingletonArray = true;\n                    }\n                    break;\n                case 'parent':\n                    result = {type: 'parent', slot: { label: '!' + ancestorLabel++, level: 1, index: ancestorIndex++ } };\n                    ancestry.push(result);\n                    break;\n                case 'string':\n                case 'number':\n                case 'value':\n                case 'wildcard':\n                case 'descendant':\n                case 'variable':\n                case 'regex':\n                    result = expr;\n                    break;\n                case 'operator':\n                    // the tokens 'and' and 'or' might have been used as a name rather than an operator\n                    if (expr.value === 'and' || expr.value === 'or' || expr.value === 'in') {\n                        expr.type = 'name';\n                        result = processAST(expr);\n                    } else /* istanbul ignore else */ if (expr.value === '?') {\n                        // partial application\n                        result = expr;\n                    } else {\n                        throw {\n                            code: \"S0201\",\n                            stack: (new Error()).stack,\n                            position: expr.position,\n                            token: expr.value\n                        };\n                    }\n                    break;\n                case 'error':\n                    result = expr;\n                    if (expr.lhs) {\n                        result = processAST(expr.lhs);\n                    }\n                    break;\n                default:\n                    var code = \"S0206\";\n                    /* istanbul ignore else */\n                    if (expr.id === '(end)') {\n                        code = \"S0207\";\n                    }\n                    var err = {\n                        code: code,\n                        position: expr.position,\n                        token: expr.value\n                    };\n                    if (recover) {\n                        errors.push(err);\n                        return {type: 'error', error: err};\n                    } else {\n                        err.stack = (new Error()).stack;\n                        throw err;\n                    }\n            }\n            if (expr.keepArray) {\n                result.keepArray = true;\n            }\n            return result;\n        };\n\n        // now invoke the tokenizer and the parser and return the syntax tree\n        lexer = tokenizer(source);\n        advance();\n        // parse the tokens\n        var expr = expression(0);\n        if (node.id !== '(end)') {\n            var err = {\n                code: \"S0201\",\n                position: node.position,\n                token: node.value\n            };\n            handleError(err);\n        }\n        expr = processAST(expr);\n\n        if(expr.type === 'parent' || typeof expr.seekingParent !== 'undefined') {\n            // error - trying to derive ancestor at top level\n            throw {\n                code: \"S0217\",\n                token: expr.type,\n                position: expr.position\n            };\n        }\n\n        if (errors.length > 0) {\n            expr.errors = errors;\n        }\n\n        return expr;\n    };\n\n    return parser;\n})();\n\nmodule.exports = parser;\n\n},{\"./signature\":5}],5:[function(require,module,exports){\n/**\n *  Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nvar utils = require('./utils');\n\nconst signature = (() => {\n    'use strict';\n\n    // A mapping between the function signature symbols and the full plural of the type\n    // Expected to be used in error messages\n    var arraySignatureMapping = {\n        \"a\": \"arrays\",\n        \"b\": \"booleans\",\n        \"f\": \"functions\",\n        \"n\": \"numbers\",\n        \"o\": \"objects\",\n        \"s\": \"strings\"\n    };\n\n    /**\n     * Parses a function signature definition and returns a validation function\n     * @param {string} signature - the signature between the <angle brackets>\n     * @returns {Function} validation function\n     */\n    function parseSignature(signature) {\n        // create a Regex that represents this signature and return a function that when invoked,\n        // returns the validated (possibly fixed-up) arguments, or throws a validation error\n        // step through the signature, one symbol at a time\n        var position = 1;\n        var params = [];\n        var param = {};\n        var prevParam = param;\n        while (position < signature.length) {\n            var symbol = signature.charAt(position);\n            if (symbol === ':') {\n                // TODO figure out what to do with the return type\n                // ignore it for now\n                break;\n            }\n\n            var next = function () {\n                params.push(param);\n                prevParam = param;\n                param = {};\n            };\n\n            var findClosingBracket = function (str, start, openSymbol, closeSymbol) {\n                // returns the position of the closing symbol (e.g. bracket) in a string\n                // that balances the opening symbol at position start\n                var depth = 1;\n                var position = start;\n                while (position < str.length) {\n                    position++;\n                    symbol = str.charAt(position);\n                    if (symbol === closeSymbol) {\n                        depth--;\n                        if (depth === 0) {\n                            // we're done\n                            break; // out of while loop\n                        }\n                    } else if (symbol === openSymbol) {\n                        depth++;\n                    }\n                }\n                return position;\n            };\n\n            switch (symbol) {\n                case 's': // string\n                case 'n': // number\n                case 'b': // boolean\n                case 'l': // not so sure about expecting null?\n                case 'o': // object\n                    param.regex = '[' + symbol + 'm]';\n                    param.type = symbol;\n                    next();\n                    break;\n                case 'a': // array\n                    //  normally treat any value as singleton array\n                    param.regex = '[asnblfom]';\n                    param.type = symbol;\n                    param.array = true;\n                    next();\n                    break;\n                case 'f': // function\n                    param.regex = 'f';\n                    param.type = symbol;\n                    next();\n                    break;\n                case 'j': // any JSON type\n                    param.regex = '[asnblom]';\n                    param.type = symbol;\n                    next();\n                    break;\n                case 'x': // any type\n                    param.regex = '[asnblfom]';\n                    param.type = symbol;\n                    next();\n                    break;\n                case '-': // use context if param not supplied\n                    prevParam.context = true;\n                    prevParam.contextRegex = new RegExp(prevParam.regex); // pre-compiled to test the context type at runtime\n                    prevParam.regex += '?';\n                    break;\n                case '?': // optional param\n                case '+': // one or more\n                    prevParam.regex += symbol;\n                    break;\n                case '(': // choice of types\n                    // search forward for matching ')'\n                    var endParen = findClosingBracket(signature, position, '(', ')');\n                    var choice = signature.substring(position + 1, endParen);\n                    if (choice.indexOf('<') === -1) {\n                        // no parameterized types, simple regex\n                        param.regex = '[' + choice + 'm]';\n                    } else {\n                        // TODO harder\n                        throw {\n                            code: \"S0402\",\n                            stack: (new Error()).stack,\n                            value: choice,\n                            offset: position\n                        };\n                    }\n                    param.type = '(' + choice + ')';\n                    position = endParen;\n                    next();\n                    break;\n                case '<': // type parameter - can only be applied to 'a' and 'f'\n                    if (prevParam.type === 'a' || prevParam.type === 'f') {\n                        // search forward for matching '>'\n                        var endPos = findClosingBracket(signature, position, '<', '>');\n                        prevParam.subtype = signature.substring(position + 1, endPos);\n                        position = endPos;\n                    } else {\n                        throw {\n                            code: \"S0401\",\n                            stack: (new Error()).stack,\n                            value: prevParam.type,\n                            offset: position\n                        };\n                    }\n                    break;\n            }\n            position++;\n        }\n        var regexStr = '^' +\n            params.map(function (param) {\n                return '(' + param.regex + ')';\n            }).join('') +\n            '$';\n        var regex = new RegExp(regexStr);\n        var getSymbol = function (value) {\n            var symbol;\n            if (utils.isFunction(value)) {\n                symbol = 'f';\n            } else {\n                var type = typeof value;\n                switch (type) {\n                    case 'string':\n                        symbol = 's';\n                        break;\n                    case 'number':\n                        symbol = 'n';\n                        break;\n                    case 'boolean':\n                        symbol = 'b';\n                        break;\n                    case 'object':\n                        if (value === null) {\n                            symbol = 'l';\n                        } else if (Array.isArray(value)) {\n                            symbol = 'a';\n                        } else {\n                            symbol = 'o';\n                        }\n                        break;\n                    case 'undefined':\n                    default:\n                        // any value can be undefined, but should be allowed to match\n                        symbol = 'm'; // m for missing\n                }\n            }\n            return symbol;\n        };\n\n        var throwValidationError = function (badArgs, badSig) {\n            // to figure out where this went wrong we need apply each component of the\n            // regex to each argument until we get to the one that fails to match\n            var partialPattern = '^';\n            var goodTo = 0;\n            for (var index = 0; index < params.length; index++) {\n                partialPattern += params[index].regex;\n                var match = badSig.match(partialPattern);\n                if (match === null) {\n                    // failed here\n                    throw {\n                        code: \"T0410\",\n                        stack: (new Error()).stack,\n                        value: badArgs[goodTo],\n                        index: goodTo + 1\n                    };\n                }\n                goodTo = match[0].length;\n            }\n            // if it got this far, it's probably because of extraneous arguments (we\n            // haven't added the trailing '$' in the regex yet.\n            throw {\n                code: \"T0410\",\n                stack: (new Error()).stack,\n                value: badArgs[goodTo],\n                index: goodTo + 1\n            };\n        };\n\n        return {\n            definition: signature,\n            validate: function (args, context) {\n                var suppliedSig = '';\n                args.forEach(function (arg) {\n                    suppliedSig += getSymbol(arg);\n                });\n                var isValid = regex.exec(suppliedSig);\n                if (isValid) {\n                    var validatedArgs = [];\n                    var argIndex = 0;\n                    params.forEach(function (param, index) {\n                        var arg = args[argIndex];\n                        var match = isValid[index + 1];\n                        if (match === '') {\n                            if (param.context && param.contextRegex) {\n                                // substitute context value for missing arg\n                                // first check that the context value is the right type\n                                var contextType = getSymbol(context);\n                                // test contextType against the regex for this arg (without the trailing ?)\n                                if (param.contextRegex.test(contextType)) {\n                                    validatedArgs.push(context);\n                                } else {\n                                    // context value not compatible with this argument\n                                    throw {\n                                        code: \"T0411\",\n                                        stack: (new Error()).stack,\n                                        value: context,\n                                        index: argIndex + 1\n                                    };\n                                }\n                            } else {\n                                validatedArgs.push(arg);\n                                argIndex++;\n                            }\n                        } else {\n                            // may have matched multiple args (if the regex ends with a '+'\n                            // split into single tokens\n                            match.split('').forEach(function (single) {\n                                if (param.type === 'a') {\n                                    if (single === 'm') {\n                                        // missing (undefined)\n                                        arg = undefined;\n                                    } else {\n                                        arg = args[argIndex];\n                                        var arrayOK = true;\n                                        // is there type information on the contents of the array?\n                                        if (typeof param.subtype !== 'undefined') {\n                                            if (single !== 'a' && match !== param.subtype) {\n                                                arrayOK = false;\n                                            } else if (single === 'a') {\n                                                if (arg.length > 0) {\n                                                    var itemType = getSymbol(arg[0]);\n                                                    if (itemType !== param.subtype.charAt(0)) { // TODO recurse further\n                                                        arrayOK = false;\n                                                    } else {\n                                                        // make sure every item in the array is this type\n                                                        var differentItems = arg.filter(function (val) {\n                                                            return (getSymbol(val) !== itemType);\n                                                        });\n                                                        arrayOK = (differentItems.length === 0);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        if (!arrayOK) {\n                                            throw {\n                                                code: \"T0412\",\n                                                stack: (new Error()).stack,\n                                                value: arg,\n                                                index: argIndex + 1,\n                                                type: arraySignatureMapping[param.subtype]\n                                            };\n                                        }\n                                        // the function expects an array. If it's not one, make it so\n                                        if (single !== 'a') {\n                                            arg = [arg];\n                                        }\n                                    }\n                                    validatedArgs.push(arg);\n                                    argIndex++;\n                                } else {\n                                    validatedArgs.push(arg);\n                                    argIndex++;\n                                }\n                            });\n                        }\n                    });\n                    return validatedArgs;\n                }\n                throwValidationError(args, suppliedSig);\n            }\n        };\n    }\n\n    return parseSignature;\n})();\n\nmodule.exports = signature;\n\n},{\"./utils\":6}],6:[function(require,module,exports){\n/**\n *  Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nconst utils = (() => {\n    'use strict';\n\n    /**\n     * Check if value is a finite number\n     * @param {float} n - number to evaluate\n     * @returns {boolean} True if n is a finite number\n     */\n    function isNumeric(n) {\n        var isNum = false;\n        if(typeof n === 'number') {\n            isNum = !isNaN(n);\n            if (isNum && !isFinite(n)) {\n                throw {\n                    code: \"D1001\",\n                    value: n,\n                    stack: (new Error()).stack\n                };\n            }\n        }\n        return isNum;\n    }\n\n    /**\n     * Returns true if the arg is an array of strings\n     * @param {*} arg - the item to test\n     * @returns {boolean} True if arg is an array of strings\n     */\n    function isArrayOfStrings(arg) {\n        var result = false;\n        /* istanbul ignore else */\n        if(Array.isArray(arg)) {\n            result = (arg.filter(function(item){return typeof item !== 'string';}).length === 0);\n        }\n        return result;\n    }\n\n    /**\n     * Returns true if the arg is an array of numbers\n     * @param {*} arg - the item to test\n     * @returns {boolean} True if arg is an array of numbers\n     */\n    function isArrayOfNumbers(arg) {\n        var result = false;\n        if(Array.isArray(arg)) {\n            result = (arg.filter(function(item){return !isNumeric(item);}).length === 0);\n        }\n        return result;\n    }\n\n    /**\n     * Create an empty sequence to contain query results\n     * @returns {Array} - empty sequence\n     */\n    function createSequence() {\n        var sequence = [];\n        sequence.sequence = true;\n        if (arguments.length === 1) {\n            sequence.push(arguments[0]);\n        }\n        return sequence;\n    }\n\n    /**\n     * Tests if a value is a sequence\n     * @param {*} value the value to test\n     * @returns {boolean} true if it's a sequence\n     */\n    function isSequence(value) {\n        return value.sequence === true && Array.isArray(value);\n    }\n\n    /**\n     *\n     * @param {Object} arg - expression to test\n     * @returns {boolean} - true if it is a function (lambda or built-in)\n     */\n    function isFunction(arg) {\n        return ((arg && (arg._jsonata_function === true || arg._jsonata_lambda === true)) || typeof arg === 'function');\n    }\n\n    /**\n     * Returns the arity (number of arguments) of the function\n     * @param {*} func - the function\n     * @returns {*} - the arity\n     */\n    function getFunctionArity(func) {\n        var arity = typeof func.arity === 'number' ? func.arity :\n            typeof func.implementation === 'function' ? func.implementation.length :\n                typeof func.length === 'number' ? func.length : func.arguments.length;\n        return arity;\n    }\n\n    /**\n     * Tests whether arg is a lambda function\n     * @param {*} arg - the value to test\n     * @returns {boolean} - true if it is a lambda function\n     */\n    function isLambda(arg) {\n        return arg && arg._jsonata_lambda === true;\n    }\n\n    // istanbul ignore next\n    var iteratorSymbol = (typeof Symbol === \"function\" ? Symbol : {}).iterator || \"@@iterator\";\n\n    /**\n     * @param {Object} arg - expression to test\n     * @returns {boolean} - true if it is iterable\n     */\n    function isIterable(arg) {\n        return (\n            typeof arg === 'object' &&\n            arg !== null &&\n            iteratorSymbol in arg &&\n            'next' in arg &&\n            typeof arg.next === 'function'\n        );\n    }\n\n    /**\n     * Compares two values for equality\n     * @param {*} lhs first value\n     * @param {*} rhs second value\n     * @returns {boolean} true if they are deep equal\n     */\n    function isDeepEqual(lhs, rhs) {\n        if (lhs === rhs) {\n            return true;\n        }\n        if(typeof lhs === 'object' && typeof rhs === 'object' && lhs !== null && rhs !== null) {\n            if(Array.isArray(lhs) && Array.isArray(rhs)) {\n                // both arrays (or sequences)\n                // must be the same length\n                if(lhs.length !== rhs.length) {\n                    return false;\n                }\n                // must contain same values in same order\n                for(var ii = 0; ii < lhs.length; ii++) {\n                    if(!isDeepEqual(lhs[ii], rhs[ii])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            // both objects\n            // must have the same set of keys (in any order)\n            var lkeys = Object.getOwnPropertyNames(lhs);\n            var rkeys = Object.getOwnPropertyNames(rhs);\n            if(lkeys.length !== rkeys.length) {\n                return false;\n            }\n            lkeys = lkeys.sort();\n            rkeys = rkeys.sort();\n            for(ii=0; ii < lkeys.length; ii++) {\n                if(lkeys[ii] !== rkeys[ii]) {\n                    return false;\n                }\n            }\n            // must have the same values\n            for(ii=0; ii < lkeys.length; ii++) {\n                var key = lkeys[ii];\n                if(!isDeepEqual(lhs[key], rhs[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @param {Object} arg - expression to test\n     * @returns {boolean} - true if it is a promise\n     */\n    function isPromise(arg) {\n        return (\n            typeof arg === 'object' &&\n                arg !== null &&\n                'then' in arg &&\n                typeof arg.then === 'function'\n        );\n    }\n\n    /**\n     * converts a string to an array of characters\n     * @param {string} str - the input string\n     * @returns {Array} - the array of characters\n     */\n    function stringToArray(str) {\n        var arr = [];\n        for (let char of str) {\n            arr.push(char);\n        }\n        return arr;\n    }\n\n    return {\n        isNumeric,\n        isArrayOfStrings,\n        isArrayOfNumbers,\n        createSequence,\n        isSequence,\n        isFunction,\n        isLambda,\n        isIterable,\n        getFunctionArity,\n        isDeepEqual,\n        stringToArray,\n        isPromise\n    };\n})();\n\nmodule.exports = utils;\n\n},{}]},{},[3])(3)\n});\n"],"names":["module","exports","r","e","n","t","o","i","f","u","a","Error","code","p","call","length","require","utils","dateTime","stringToArray","few","ordinals","decades","magnitudes","numberToWords","value","ordinal","lookup","num","prev","ord","words","tens","Math","floor","remainder","substring","hundreds","mag","log10","factor","pow","mant","wordValues","wordsToNumber","text","values","split","map","part","segs","forEach","top","pop","push","reduce","b","word","index","toLowerCase","lword","hundredth","val","romanNumerals","romanValues","decimalToRoman","numeral","romanToDecimal","roman","decimal","max","digit","decimalToLetters","aChar","letters","aCode","charCodeAt","unshift","String","fromCharCode","join","lettersToDecimal","formatInteger","picture","_formatInteger","analyseIntegerPicture","formats","DECIMAL","LETTERS","ROMAN","WORDS","SEQUENCE","tcase","UPPER","LOWER","TITLE","format","formattedInteger","negative","abs","primary","case","toUpperCase","padLength","mandatoryDigits","padding","Array","zeroCode","fromCodePoint","codePointAt","regular","ii","groupingSeparators","position","pos","substr","character","reverse","separator","suffix","token","decimalGroups","type","primaryFormat","formatModifier","semicolon","lastIndexOf","optionalDigits","separatorPosition","c","codePoint","group","separators","sepChar","indexes","gcd","indexOf","regularRepeat","defaultPresentationModifiers","Y","M","D","d","F","W","w","X","x","H","h","P","m","s","Z","z","C","E","analyseDateTimePicture","spec","parts","addLiteral","start","end","literal","charAt","marker","presMod","def","component","comma","widthMod","dash","min","parseWidth","wm","parseInt","widthDef","width","presentation1","lastChar","presentation2","names","integerPattern","integerFormat","undefined","days","months","millisInADay","startOfFirstWeek","ym","jan1","Date","UTC","year","month","dayOfJan1","getUTCDay","yearMonth","nextMonth","previousMonth","nextYear","previousYear","deltaWeeks","getDateTimeFragment","date","componentValue","getUTCFullYear","getUTCMonth","getUTCDate","thisYear","startOfWeek1","today","week","startOfPreviousYear","thisMonth","startOfPreviousMonth","startOfISOYear","endOfISOYear","now","getTime","startOfISOMonth","endOfISOMonth","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","iso8601Spec","formatDateTime","millis","timezone","offsetHours","offsetMinutes","offset","formatComponent","markerSpec","numDigits","formatSpec","result","generateRegex","matcher","res","regex","replace","isArray","parse","Number","name","isUpper","occurrences","Object","keys","concat","digits","sep","char","parseInteger","parseDateTime","timestamp","matchSpec","fullRegex","info","RegExp","exec","dmA","dmB","dmC","dmD","tmA","tmB","components","mpart","getOwnPropertyNames","mask","shift","bit","isType","dateB","dateC","dateD","timeB","comps","this","environment","startSpecified","endSpecified","firstJan","offsetMillis","derivedDate","iso8601regex","toMillis","test","stack","fromMillis","global","functions","isNumeric","isArrayOfStrings","isArrayOfNumbers","createSequence","isSequence","isFunction","isLambda","isPromise","getFunctionArity","deepEquals","isDeepEqual","sum","args","total","count","apply","average","string","arg","prettify","str","isFinite","space","outerWrapper","JSON","stringify","key","toPrecision","strArray","strLength","slice","substringBefore","chars","substringAfter","lowercase","uppercase","trim","pad","async","evaluateMatcher","groups","next","contains","match","limit","matches","pattern","replacement","replacer","self","regexMatch","substitute","dollarVal","maxDigits","log","LOG10E","isNaN","submatch","toString","replacedWith","base64encode","btoa","window","Buffer","from","base64decode","atob","encodeUrlComponent","returnVal","encodeURIComponent","functionName","encodeUrl","encodeURI","decodeUrlComponent","decodeURIComponent","decodeUrl","decodeURI","strs","formatNumber","options","properties","decimalDigitFamily","zeroCharCode","activeChars","subPictures","splitParts","subpicture","mantissaPart","exponentPart","integerPart","fractionalPart","prefix","ch","activePart","exponentPosition","decimalPosition","validate","error","decimalPos","percent","valid","optionalDigitPos","filter","exponentExists","analyse","getGroupingPositions","toLeft","positions","groupingPosition","charsToTheRight","integerPartGroupingPositions","regularGrouping","fractionalPartGroupingPositions","minimumIntegerPartSize","scalingFactor","fractionalPartArray","minimumFactionalPartSize","maximumFactionalPartSize","exponentPresent","minimumExponentSize","pic","adjustedNumber","mantissa","exponent","variables","minus_sign","zero_digit","decimal_separator","grouping_separator","maxMantissa","minMantissa","makeString","dp","toFixed","stringValue","round","padLeft","padRight","groupCount","stringExponent","formatBase","radix","number","parseFloat","ceil","precision","diff","is","sqrt","power","exp","random","boolean","not","hofFuncArgs","func","arg1","arg2","arg3","func_args","arr","entry","single","hasFoundMatch","positiveResult","zip","prototype","arguments","tuple","foldLeft","sequence","init","arity","merge","item","input","append","exists","spread","obj","prop","each","message","assert","condition","sort","comparator","comp","l","merge_iter","left","right","merged","msort","array","middle","shuffle","j","distinct","results","includes","jj","sift","g","datetime","fn","parser","parseSignature","jsonata","isIterable","staticFrame","createFrame","evaluate","expr","entryCallback","Symbol","for","evaluatePath","evaluateBinary","evaluateUnary","evaluateName","evaluateLiteral","evaluateWildcard","evaluateDescendants","slot","label","evaluateCondition","evaluateBlock","evaluateBindExpression","evaluateRegex","evaluateFunction","evaluateVariable","evaluateLambda","evaluatePartialApplication","evaluateApplyExpression","evaluateTransformExpression","hasOwnProperty","predicate","evaluateFilter","evaluateGroupExpression","exitCallback","tupleStream","keepArray","keepSingleton","inputSequence","resultSequence","steps","isTupleStream","tupleBindings","step","consarray","evaluateTupleStep","evaluateStep","focus","keepSingletonArray","cons","createFrameFromTuple","frame","bind","lastStep","evaluateSortExpression","stages","evaluateStages","ss","stage","ee","sorted","stepEnv","bb","assign","ancestor","context","env","ires","lhs","op","evalrhs","rhs","evaluateBooleanExpression","err","evaluateNumericExpression","evaluateEqualityExpression","evaluateComparisonExpression","evaluateStringConcat","evaluateRangeExpression","evaluateIncludesExpression","expression","generators","Promise","all","expressions","idx","isParallelCall","generator","defineProperty","enumerable","configurable","flatten","flattened","recurseDescendants","member","ltype","rtype","value2","lBool","boolize","booledValue","lstr","rstr","itemIndex","pairIndex","pair","data","exprIndex","reduceTupleStream","isInteger","size","then","else","re","RegexEngine","closure","fromIndex","lastIndex","source","isTupleSort","terms","term","aa","atype","btype","descending","defineFunction","cloneFunction","isPrototypeOf","constructor","update","updateType","delete","deletions","chainAST","chain","applyto","proc","procedure","evaluatedArgs","params","procName","applyInner","thunk","body","validatedArgs","validateArguments","signature","applyProcedure","_jsonata_function","implementation","_jsonata_lambda","partialApplyProcedure","partialApplyNativeFunction","param","applyNativeFunction","unboundArgs","native","sigArgs","getNativeFunctionArguments","sigArg","bodyAST","definition","functionEval","ast","populateMessage","functionClone","enclosingEnvironment","bindings","newFrame","ancestry","framePushCallback","errorCodes","template","errors","recover","callback","exec_env","it","v","registerFunction","operators","escapes","tokenizer","path","create","scanRegex","flags","depth","isClosingSlash","backslashCount","currentChar","commentStart","quoteType","qstr","octets","codepoint","node","lexer","symbol_table","remainingTokens","remaining","id","nxt","base_symbol","nud","symbol","bp","lbp","handleError","advance","infix","next_token","rbp","led","terminal","bindingPower","infixr","sigPos","sig","tok","range","objectParser","tailCallOptimize","ancestorLabel","ancestorIndex","seekParent","level","pushAncestry","seekingParent","slots","resolveAncestry","laststep","processAST","lstep","rest","nextFunction","lit","firststep","sortStep","argAST","arraySignatureMapping","prevParam","findClosingBracket","openSymbol","closeSymbol","contextRegex","endParen","choice","endPos","subtype","regexStr","getSymbol","throwValidationError","badArgs","badSig","partialPattern","goodTo","suppliedSig","isValid","argIndex","contextType","arrayOK","itemType","isNum","iteratorSymbol","iterator","lkeys","rkeys"],"sourceRoot":""}